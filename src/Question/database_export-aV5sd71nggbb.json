{"_id":"7a79bfab62bd5a3f00db568215e36e9e","basicData":[{"title":"计算机网络","questions":["Internet 如何工作","HTTP 协议","浏览器工作机制","DNS 及其运行机制","了解域名、网站托管"]},{"title":"前端基础","content":[{"title":"HTML","questions":["学习 HTML 基础，标签、元素、表单验证等等","语义化标签","了解 Web 无障碍（Accessibility）","学习 SEO 基础的优化"]},{"title":"CSS","questions":["CSS 基础","制作布局：浮动、定位、显示、盒模型、网格布局、弹性布局","响应式设计和媒体查询（@media）","结合 HTML 制作一个简单的网页作为最佳实践"]},{"title":"JavaScript","questions":["学习语法和基本结构","学习操作 DOM","学习 Fetch API / Ajax（XHR）","ES6+ 和模块化 JavaScript","了解变量提升、事件冒泡机制、作用域、原型、Shadow DOM、严格模式等概念"]}]},{"title":"版本控制","questions":["Git 的基本操作","创建账号并且学习使用 GitHub"]},{"title":"Web 安全知识","questions":["HTTPS","内容安全策略（CSP）","跨域资源共享","OWASP 安全风险"]}],"engineerData":[{"title":"包管理工具","questions":["npm","yarn","nvm"]},{"title":"CSS 预处理器","questions":["SASS","Less","PostCss"]},{"title":"构建工具","content":[{"title":"任务执行器","questions":["npm scripts"]},{"title":"代码检查和格式化工具","questions":["Prettier 代码格式化","ESLint 代码检查"]},{"title":"模块打包","questions":["webpack","rollup","Vite"]}]}],"frontEndFrame":[{"title":"前端框架","questions":["Solid","Svelte"],"content":[{"title":"React.js","questions":["Redux （状态管理）","MobX"]},{"title":"Vue.js","questions":["VueX （状态管理）"]},{"title":"Vue.js","questions":["VueX （状态管理）"]},{"title":"Angular","questions":["RxJS","NgRx"]}]}],"unitTest":[{"title":"单元测试","questions":["Jest","react-testing-library"]}],"typeScript":[{"title":"类型检查器","questions":["TypeScript"]}],"serverRendar":[{"title":"服务端渲染","questions":["Next.js (React.js)","Nuxt.js (Vue.js)","Universal（Angular）"]}],"mobileApp":[{"title":"移动端应用开发","questions":["ReactNative","Flutter"]}],"title":"前端学习框架","keyWord":"frameWork"}
{"_id":"7a79bfab62c00a2c01028826366b032d","html":[{"ansysis":"参考答案：\n\n①用正确的标签做正确的事情。\n\n②html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\n\n③ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;\n\n④ 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。","category":"html","title":"简述一下你对 HTML 语义化的理解？"},{"title":"Label 的作用是什么？是怎么用的？","ansysis":"参考答案：label 标签来定义表单控制间的关系, 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。","category":"html"},{"ansysis":"参考答案：\n\n优点：\niframe 能够原封不动的把嵌入的网页展现出来。\n如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。\n网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。\n如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。\n缺点：\n框架结构中出现各种滚动条\niframe 会阻塞主页面的 Onload 事件\n搜索引擎的检索程序无法解读这种页面，不利于 SEO\niframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。","category":"html","title":"iframe 框架有哪些优缺点？"},{"ansysis":"应该使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：\n\n1、XHTML中所有的标记都必须有一个相应的结束标签；\n\n2、XHTML所有标签的元素和属性的名字都必须使用小写；\n\n3、所有的XML标记都必须合理嵌套；\n\n4、所有的属性都必须用引号“”括起来；\n\n5、把所有<和&特殊符号用编码表示；\n\n6、给所有属性附一个值；\n\n7、不要在注释内容中使用“--”；\n\n8、图片必须使用说明文字。","category":"html","title":"HTML 与 XHTML 二者有什么区别，你觉得应该使用哪一个并说出理由。"},{"ansysis":"参考答案：将不想要自动完成的 form 或 input 设置为 autocomplete=off\n\n","category":"html","title":"HTML5 的 form 如何关闭自动完成功能？"},{"category":"html","title":"title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？","ansysis":"\n①title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，seo权重高于H1；H1概括的是文章主题，一个页面最好只用一个H1，seo权重低于title。\n\n解析：\n\nA.从网站角度而言，title则重于网站信息标题，突出网站标题或关键字用title，一篇文章，一个页面最好只\n\n用一个H1，H1用得太多，会稀释主题；一个网站可以有多个title，最好一个单页用一个title以便突出网站页面\n\n主题信息。\n\nB.从文章角度而言，H1则概括的是文章主题，突出文章主题，用H1，面对的用户，要突出其视觉效果。\n\nC.从SEO角度而言，title的权重高于H1，其适用性要比H1广。\n\n②b为了加粗而加粗，strong为了标明重点而加粗\n\n解析：\n\nA.b这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；\n\nB.strong这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；\n\n③ 同②i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i要重视的多"},{"ansysis":"参考答案：在 SEO 中，所谓的 TDK 其实就是 title、description、keywords 这三个标签，title 标题标签，description 描述标签，keywords 关键词标签","category":"html","title":"请描述下 SEO 中的 TDK？"},{"ansysis":"参考答案： <! DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。\n\n告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n\n告诉浏览器按照何种规范解析页（如果你的页面没有 DOCTYPE 的声明，那么 compatMode 默认就是 BackCompat, 浏览器按照自己的方式解析渲染页面）\n\n解析：\n\ndoctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。\n\n<! DOCTYPE>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。\n\n<! DOCTYPE>声明必须是HTML文档的第一行，位于html标签之前。\n\n浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 doctype 来区分这两种模式，doctype 在 html 中的作用就是触发浏览器的标准模式，如果 html 中省略了 doctype，浏览器就会进入到 Quirks 模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而 html 标准和 dom 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 html 开头使用 doctype。","category":"html","title":"每个 HTML 文件头里都有个很重要的东西，Doctype，知道这是干什么的么？"},{"ansysis":"参考答案：src 用于引用资源，替换当前元素；href 用于在当前文档和引用资源之间确立联系。\n\n解析：\n\nhref\nhref 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，是在当前元素和引用资源之间建立联系\n若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。\nsrc\nsrc 表示引用资源，替换当前元素，用在 img，script，iframe 上，src 是页面内容不可缺少的一部分。\n当浏览器解析到 src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。","category":"html","title":"简述一下 src 与 href 的区别。"},{"ansysis":"参考答案：\n\n严格模式：以浏览器支持的最高标准运行\n\n混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为","category":"html","title":"严格模式与混杂模式"},{"ansysis":"参考答案：\n\nweb 标准简单来说可以分为结构、表现和行为。其中结构主要是有 HTML 标签组成。或许通俗点说，在页面 body 里面我们写入的标签都是为了页面的结构。表现即指 css 样式表，通过 css 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 js 组成。\n\nweb 标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。\n\nW3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点\n\n对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）\n1）标签字母要小写\n\n2）标签要闭合\n\n3）标签不允许随意嵌套\n\n对于 css 和 js 来说\n1）尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。\n\n2）样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版\n\n3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。","category":"html","title":"对于 WEB 标准以及 W3C 的理解与认识问题"},{"ansysis":"参考答案：\n\na. IE 的排版引擎是 Trident （又称为 MSHTML）\n\nb. Trident 内核曾经几乎与 W3C 标准脱节（2005 年）\n\nc. Trident 内核的大量 Bug 等安全性问题没有得到及时解决\n\nd. JS 方面，有很多独立的方法，例如绑定事件的 attachEvent、创建事件的 createEventObject 等\n\ne. CSS 方面，也有自己独有的处理方式，例如设置透明，低版本 IE 中使用滤镜的方式","category":"html","title":"列举 IE 与其他浏览器不一样的特性"},{"category":"html","title":"前端页面有哪三层构成，分别是什么？作用是什么？","ansysis":"参考答案：分成：结构层、表示层、行为层。\n\n结构层（structural layer）\n由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”\n\n表示层（presentation layer）\n由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。\n\n行为层（behaviorlayer）\n负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。"},{"ansysis":"参考答案：\n\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试","category":"html","title":"网页验证码是干嘛的，是为了解决什么安全问题？"},{"title":"为什么用多个域名存储网站资源更有效？","ansysis":"参考答案：\n\n1、CDN 缓存更方便\n\n2、突破浏览器并发限制\n\n3、节约 cookie 带宽\n\n4、节约主域名的连接数，优化页面响应速度\n\n5、防止不必要的安全问题","category":"html"},{"ansysis":"参考答案：\n\n页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是.........，(把浏览器最小化，所有的页面就都不可见了)。\n\nAPI 很简单，document.hidden 就返回一个布尔值，如果是 true, 表示页面可见，false 则表示，页面隐藏。 不同页面之间来回切换，触发 visibilitychange 事件。 还有一个 document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。\n\ndocument.addEventListener(\"visibilitychange\", function() {\n    if (document.hidden) {\n        document.title = \"hidden\";\n    } else {\n        document.title = \"visibile\";\n    }\n});\n我们打开这个页面，然后再打开另一个页面，来回点击这两个页面，当我们看到这个页面时，标题显示 visiable , 当我们看另一个页面时，标题显示 hidden;","category":"html","title":"页面可见性（Page Visibility）API 可以有哪些用途？"},{"category":"html","title":"Quirks(怪癖）模式是什么？它和 Standards（标准）模式有什么区别","ansysis":"参考答案：\n\n1 以 ie6 为例，如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。\n\n2 区别：总体会有布局、样式解析和脚本执行三个方面的区别。\n\n设置一个元素的宽度和高度\n\n给 <span> 等行内元素设置 width 和 height\n\n用 margin:0 auto 设置水平居中\n\n从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。\n\n在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6  支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？\n\n在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数   不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定   如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。\n\n区别：\n\n总体会有布局、样式解析和脚本执行三个方面的区别。\n\n盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks  模式下，IE 的宽度和高度还包含了 padding 和 border。\n\n设置行内元素的高宽：在 Standards 模式下，给 <span> 等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。\n\n设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的\n\n用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。\n\n（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）"},{"title":"div+css 的布局较 table 布局有什么优点？","ansysis":"参考答案：分离 方便改版 快清晰简洁 seo\n\n改版的时候更方便 只要改 css 文件。\n\n页面加载速度更快、结构化清晰、页面显示简洁。\n\n表现与结构相分离。\n\n易于优化（seo）搜索引擎更友好，排名更容易靠前。","category":"html"},{"ansysis":"参考答案：\n\n渐进增强  progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n（一开始保证最基本的功能，再改进和追加功能）\n\n优雅降级  graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n（一开始就构建完整的功能，再针对低版本浏览器进行兼容。）\n\n区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。","category":"html","title":"你能描述一下渐进增强和优雅降级之间的不同吗?"},{"title":"请谈一下你对网页标准和标准制定机构重要性的理解。","ansysis":"参考答案：降低开发难度及开发成本，减少各种 BUG、安全问题， 提高网站易用性","category":"html"},{"title":"html 常见兼容性问题？","ansysis":"参考答案：\n\n双边距 BUG float 引起的，解决办法: 使用 display解决\n2.3 像素问题 使用 float 引起的，解决办法: 使用 dislpay:inline -3px\n\n超链接 hover 点击后失效，解决办法: 使用正确的书写顺序 link visited hover active\n\nIe z-index 问题，解决办法: 给父级添加 position:relative\n\nPng 透明 ，解决办法: 使用 js 代码\n\nMin-height 最小高度 ，解决办法: ！Important 解决\n\n7.select 在 ie6 下遮盖，解决办法: 使用 iframe 嵌套\n\n为什么没有办法定义 1px 左右的宽度容器，解决办法: （IE6 默认的行高造成的，使用 over:hidden, zoom:0.08 line-height:1px）\n\nIE5-8 不支持 opacity，解决办法：\n\n.opacity {\n    opacity: 0.4;\n    filter: alpha(opacity=60);/_ for IE5-7 _/ -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=60)\";/_ for IE 8_/\n}\nIE6 不支持 PNG 透明背景，解决办法: IE6 下使用 gif 图片","category":"html"},{"category":"html","title":"对 WEB 标准以及 W3C 的理解与认识","ansysis":"参考答案：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。"},{"title":"如何在页面上实现一个圆形的可点击区域？","ansysis":"参考答案：css3、js、map 加 area\n\n一.border-radius (css3)\n\n对于圆形，最直接的方法想到的就是 css3 的圆角属性，这个属性可以将 html 元素的形状设置为圆形，这之后你想对该圆形区域设置什么事件就设置什么事件(当然包括点击)。（这里就不做具体的 test 了）\n\n二. 通过事件坐标来实现（js）\n\n也就是通过 js 来进行一个区域判断，进而简介地的形成可点区域","category":"html"},{"ansysis":"参考答案：\n\n合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可\n\n语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页\n\n重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n\n重要内容不要用 js 输出：爬虫不会执行 js 获取内容\n\n少用 iframe：搜索引擎不会抓取 iframe 中的内容\n\n非装饰性图片必须加 alt\n\n提高网站速度：网站速度是搜索引擎排序的一个重要指标","category":"html","title":"前端需要注意哪些 SEO"},{"ansysis":"参考答案：\n\n新特性：\n\n拖拽释放(Drag and drop) API\n\n语义化更好的内容标签（header,nav,footer,aside,article,section）\n\n音频、视频 API(audio,video)\n\n画布(Canvas) API\n\n地理(Geolocation) API\n\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n\nsessionStorage 的数据在浏览器关闭后自动删除\n\n表单控件，calendar、date、time、email、url、search\n\n新的技术 webworker, websocket, Geolocation\n\n移除的元素：\n\n纯表现的元素：basefont，big，center，font, s，strike，tt，u；\n\n对可用性产生负面影响的元素：frame，frameset，noframes；\n\n支持 HTML5 新标签：\n\nIE8/IE7/IE6 支持通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签， 浏览器支持新标签后，还需要添加标签默认的样式：\n当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架","category":"html","title":"html5 有哪些新特性、移除了那些元素？"},{"ansysis":"参考答案：\n\n在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\n原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。","category":"html","title":"HTML5 的离线储存怎么使用，工作原理能不能解释一下？"},{"ansysis":"参考答案：在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。","category":"html","title":"浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢"},{"ansysis":"参考答案：\n\naccesskey: 设置快捷键，提供快速访问元素如aaa在 windows 下的 firefox 中按 alt + shift + a 可激活元素\nclass: 为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素\ncontenteditable: 指定元素内容是否可编辑\ncontextmenu: 自定义鼠标右键弹出菜单内容\ndata-*: 为元素增加自定义属性\ndir: 设置元素文本方向\ndraggable: 设置元素是否可拖拽\ndropzone: 设置元素拖放类型： copy, move, link\nhidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果\nid: 元素 id，文档内唯一\nlang: 元素内容的的语言\nspellcheck: 是否启动拼写和语法检查\nstyle: 行内 css 样式\ntabindex: 设置元素可以获得焦点，通过 tab 可以导航\ntitle: 元素相关的建议信息\ntranslate: 元素和子孙节点内容是否需要本地化","category":"html","title":"HTML 全局属性(global attribute)有哪些"},{"ansysis":"参考答案：Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。\n\nCanvas 通过 Javascript 来绘制 2D 图形。 是逐像素进行渲染的。 其位置发生改变，会重新进行绘制。\nSVG 是一种使用 XML 描述的 2D 图形的语言 SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\nCanvas\n\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以 .png 或 .jpg 格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\nSVG\n\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n不适合游戏应用","category":"html","title":"Canvas 和 SVG 有什么区别？"},{"ansysis":"参考答案：HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML 是标准通用标记语言, 简单的说，就是比 HTML, XML 更老的标准，这两者都是由 SGML 发展而来的。BUT，HTML5 不是的。\n\n<! DOCTYPE> 声明位于位于 HTML 文档中的第一行，处于 <html> 标签之前。作用：告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以怪异模式呈现","category":"html","title":"HTML5 为什么只需要写 <! DOCTYPE HTML> ？"},{"ansysis":"参考答案：\n\nmeta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放\n\nviewport的原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户；\n\n解析：\n\nViewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。\n\n在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。 举个例子：如果我们的屏幕是 320 像素 * 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。\n\n为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。\n\nViewport 属性值\nwidth 设置 layout viewport 的宽度，为一个正整数，或字符串\"width-device\"\ninitial-scale 设置页面的初始缩放值，为一个数字，可以带小数\nminimum-scale 允许用户的最小缩放值，为一个数字，可以带小数\nmaximum-scale 允许用户的最大缩放值，为一个数字，可以带小数\nheight 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用\nuser-scalable 是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。\n","category":"html","title":"meta viewport 原理是什么？"},{"ansysis":"参考答案：\n\n可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。\n\n可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性\n\n可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。","category":"html","title":"对 web 标准、可用性、可访问性的理解"},{"category":"html","title":"HTML5 引入什么新的表单属性？","ansysis":"参考答案：Datalist datetime output keygen date month week time number range emailurl\n\n"},{"ansysis":"HTML5文档类型：<!doctype html>\nHTML5使用的编码<meta charset=”UTF-8”>","category":"html","title":"新的 HTML5 文档类型和字符集是？"},{"ansysis":"参考答案：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。\n\n","category":"html","title":"HTML5 Canvas 元素有什么用？"},{"category":"html","title":"HTML5 存储类型有什么区别？","ansysis":"参考答案：Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API"},{"category":"html","title":"iframe 的作用","ansysis":"参考答案：iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载。\n\n优点\n\n便于修改，模拟分离，像一些信息管理系统会用到。\n但现在基本不推荐使用。除非特殊需要，一般不推荐使用。\n缺点\n\niframe 的创建比一般的 DOM 元素慢了 1-2 个数量级\niframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。\niframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。\n"},{"title":"为什么最好把 CSS 的 <link> 标签放在 <head></head> 之间？为什么最好把 JS 的 <script> 标签恰好放在 </body> 之前，有例外情况吗？","ansysis":"参考答案：\n\n把 <link> 放在 <head> 中\n\n把 <link> 标签放在 <head></head> 之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。\n\n把 <script> 标签恰好放在 </body> 之前\n\n脚本在下载和执行期间会阻止 HTML 解析。把 <script> 标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。\n\n例外情况是当你的脚本里包含 document.write() 时。但是现在， document.write() 不推荐使用。同时，将 <script> 标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是， <script> 使用 defer 属性，放在 <head> 中。","category":"html"},{"ansysis":"参考答案：\n\nDOM\nDocument Object Model，文档对象模型\n\nDOM 是为了操作文档出现的 API，document 是其的一个对象\n\nDOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容。\n\nBOM\nBrowser Object Model，浏览器对象模型\n\nBOM 是为了操作浏览器出现的 API，window 是其的一个对象\n\nwindow 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象","category":"html","title":"DOM 和 BOM 有什么区别"},{"ansysis":"参考答案：title 指图片的信息、alt 指图片不显示时显示的文字","category":"html","title":"img 上 title 与 alt"},{"ansysis":"参考答案：\n\ncss的方案\nonresize\n监听鼠标动作，鼠标释放后重新定宽","category":"html","title":"一个iframe，内嵌了一个A页面，iframe的宽高不停变化，如何让A页面的宽高实时自适应这个iframe的宽高大小。请说出至少3种方法，越难越好"},{"ansysis":"参考答案：\n\nHTML 解释器\nHTML 解释器的工作就是将网络或者本地磁盘获取的 HTML 网页和资源从字节流解释成 DOM 树结构。\n\nJavaScript 的执行\n在 HTML 解释器的工作过程中，可能会有 JavaScript 代码需要执行，它发生在将字符串解释成词语之后、创建各种节点的时候。这也是为什么全局执行的 JavaScript 代码不能访问 DOM 的原因——因为 DOM 树还没有被创建完呢。","category":"html","title":"DOM Tree是如何构建的？"},{"ansysis":"参考答案：noscript 元素用来定义在脚本未被执行时的替代内容（文本）。\n\n此标签可被用于可识别 <script> 标签但无法支持其中的脚本的浏览器。","category":"html","title":"<noscript> 标签的作用"},{"category":"html","title":"DOCTYPE 的作用是什么？","ansysis":"参考答案：\n\n相关知识点：\n\nIE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。\n\n<!DOCTYPE>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。\n\nDOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。\n回答（参考1-5）：\n\n<!DOCTYPE>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来\n进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏\n览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。\n\n在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文\n档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。"},{"ansysis":"参考答案：\nSGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。\n\nHTML 是超文本标记语言，主要是用于规定怎么显示网页。\n\nXML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，\n而 HTML 的标签都是固定的而且数量有限。\n\nXHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML \n更严格，比如标签必须都用小写，标签都必须有闭合标签等。","category":"html","title":"SGML 、 HTML 、XML 和 XHTML 的区别？"},{"ansysis":"参考答案：\nHTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空\n间。\n\n常见的行内元素有 a b span img strong sub sup button input label select textarea","category":"html","title":"行内元素定义"},{"ansysis":"参考答案：\n块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。\n\n常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p ","category":"html","title":"块级元素定义"},{"category":"html","title":"行内元素与块级元素的区别？","ansysis":"参考答案：\nHTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。\n\n（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。\n（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。\n（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei\n     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。"},{"ansysis":"参考答案：\nHTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前\n端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为\ninline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为\ninline 与 block 已经不再符合实际需求。\n\nHTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive","category":"html","title":"HTML5 元素的分类"},{"title":" 空元素定义","ansysis":"参考答案：\n标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。\n\n常见的空元素有：br hr img input link meta","category":"html"},{"ansysis":"参考答案：\nlink 标签定义文档与外部资源的关系。\n\nlink 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。\n\nlink 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。","category":"html","title":"link 标签定义"},{"ansysis":"参考答案：\n\n（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加\n     载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。\n\n（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。\n\n（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容\n     性问题。\n\n（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i\n    mport 的方式插入样式。","category":"html","title":"页面导入样式时，使用 link 和 @import 有什么区别？"},{"title":"async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）","ansysis":"参考答案：\n\n （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执\n     行。\n\n （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。\n     当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。\n\n （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执\n     行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。","category":"html"},{"ansysis":"参考答案：\n\n Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加\n 载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析\n 过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。","category":"html","title":"什么是文档的预解析？（浏览器解析过程）"},{"ansysis":"参考答案：\n\n 理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可\n 能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。\n\n 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档\n 的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，\n 最后再继续文档的解析。","category":"html","title":"CSS 如何阻塞文档解析？（浏览器解析过程）"},{"ansysis":"参考答案：\n\n FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示\n       出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底\n       部。\n\n 白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML \n      尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面\n      文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。","category":"html","title":"渲染页面时常见哪些不良现象？（浏览器渲染过程）"},{"title":" 如何优化关键渲染路径？（浏览器渲染过程）","ansysis":"参考答案：\n\n 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n （1）关键资源的数量。\n （2）关键路径长度。\n （3）关键字节的数量。\n\n 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。\n\n 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，\n 并且资源越大，下载所需的往返次数就越多。\n\n 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它\n 们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n\n 优化关键渲染路径的常规步骤如下：\n\n （1）对关键路径进行分析和特性描述：资源数、字节数、长度。\n （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。\n （3）优化关键字节数以缩短下载时间（往返次数）。\n （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。","category":"html"},{"ansysis":"参考答案：\n\n 重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。\n \n 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。\n\n 常见引起回流属性和方法：\n\n 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。\n\n （1）添加或者删除可见的 DOM 元素；\n （2）元素尺寸改变——边距、填充、边框、宽度和高度\n （3）内容变化，比如用户在 input 框中输入文字\n （4）浏览器窗口尺寸改变——resize事件发生时\n （5）计算 offsetWidth 和 offsetHeight 属性\n （6）设置 style 属性的值\n （7）当你修改网页的默认字体时。\n\n 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。","category":"html","title":"什么是重绘和回流？（浏览器绘制过程）"},{"ansysis":"参考答案：\n\n （1）使用 transform 替代 top\n\n （2）不要把节点的属性值放在一个循环里当成循环里的变量\n\n （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局\n\n （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM\n\n （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。","category":"html","title":"如何减少回流？（浏览器绘制过程）"},{"ansysis":"参考答案：\n\n 一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。","category":"html","title":"为什么操作 DOM 慢？（浏览器绘制过程）"},{"title":"DOMContentLoaded 事件和 Load 事件的区别？","ansysis":"参考答案：\n\n 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和\n 子框架的加载完成。\n\n Load 事件是当所有资源加载完成后触发的。","category":"html"},{"ansysis":"参考答案：\n\n HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n\n 新增的有：\n  \n 绘画 canvas;\n 用于媒介回放的 video 和 audio 元素;\n 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n sessionStorage 的数据在浏览器关闭后自动删除;\n 语意化更好的内容元素，比如 article、footer、header、nav、section;\n 表单控件，calendar、date、time、email、url、search;\n 新的技术 webworker, websocket;\n 新的文档属性 document.visibilityState\n\n 移除的元素有：\n\n 纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n 对可用性产生负面影响的元素：frame，frameset，noframes；","category":"html","title":"HTML5 有哪些新特性、移除了那些元素？"},{"title":"如何处理 HTML5 新标签的浏览器兼容问题？","ansysis":"参考答案：\n\n （1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器\n     支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。\n\n （2） 当然也可以直接使用成熟的框架，比如 html5shiv ;\n      `<!--[if lt IE 9]>\n      <script> src=\"https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js\"</script>\n      <![endif]-->`\n\n      [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。","category":"html"},{"title":"简述一下你对 HTML 语义化的理解？","ansysis":"参考答案：\n\n相关知识点：\n\n （1） 用正确的标签做正确的事情。\n （2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n （3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\n （4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;\n （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n回答：\n\n 我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，\n 一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进\n 行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。\n 对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的\n 话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会\n 依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，\n 从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、fo\n oter 这些语义标签，删除了 big 、font 这些没有语义的标签。","category":"html"},{"ansysis":"参考答案：根据同源策略，cookie是区分端口的，但是浏览器实现来说，“cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的。","category":"html","title":"如何在不同的端口间共享cookie？"},{"title":"前端性能优化？","ansysis":"参考答案：前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。\\n\\n 第一个方面是页面的内容方面\\n\\n （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。\\n\\n （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。\\n\\n （3）通过设置缓存策略，对常用不变的资源进行缓存。\\n\\n （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。\\n\\n （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。\\n\\n 第二个方面是服务器方面\\n\\n （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。\\n\\n （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。\\n\\n （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie\\n\\n 第三个方面是 CSS 和 JavaScript 方面\\n\\n （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。\\n\\n （2）避免使用 @import 标签。\\n\\n （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。\\n\\n （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。","category":"html"}],"keyWord":"html","hasAnser":true,"title":"HTML 面试题"}
{"_id":"7a79bfab62c13f020108444837e0fad1","headerImg":"https://mmbiz.qpic.cn/mmbiz_jpg/uvBQ6bLUlsjT6j3fPZHyiap9iabKiaBdibXiatJoPaV6AZMYEzvYQpReQcOhEibzVUWoC7hOp8vYKibudlA7nUUezmIBw/0?wx_fmt=jpeg","showData":{"serviceContent":[{"title":"前端基础","subTitle":"包含 HTML、CSS、JS 以及计算机网络的面试题","jumpUrl":"/pages/interview/interview","icon":"/images/icon/jichu-Basics.png"},{"title":"高频题目","subTitle":"面试中常见且必须要熟悉和掌握的题目","jumpUrl":"/pages/listPage/listPage","keyWord":"highFrequency","icon":"/images/icon/important.png"},{"title":"知识体系","subTitle":"学习前端需要了解及掌握的各类知识点","jumpUrl":"/pages/frame/frame","keyWord":"freamWork","icon":"/images/icon/financial_framework.png"},{"title":"文章分享","subTitle":"一些公众号文章，有关职场新人的注意事项","jumpUrl":"/pages/otherShare/otherShare","icon":"/images/icon/kuozhangongneng.png"}],"gotoMiniApp":[{"title":"C 语言","icon":"/images/icon/cyuyan.png","appId":"wx6bebdccd4af55c3d","path":"pages/finalExam/finalExam"}]},"title":"首页数据"}
{"_id":"6a6a269a62c1880b01104dac7d30d75a","keyWord":"highFrequency","hasAnser":true,"title":"前端高频面试题","highFrequency":[{"ansysis":"语义化就是选择与语义相符合的标签，使代码语义化，这样不仅便于开发者进行阅读，同时也能维护和写出更优雅的代码，还能够让搜索引擎和浏览器等工具更好地解析。\n通俗的讲语义化就是让正确的标签做正确的事情，比如段落用p标签，头部用header标签，主要内容用main标签，侧边栏用aside标签等等。","category":"highFrequency","title":"说一下对HTML语义化的理解?"},{"ansysis":"将视口大小设置为可视区域的大小。\n什么是视口\n视口简单理解就是可视区域大小。\n在PC端，视口大小就是浏览器窗口可视区域的大小\n在移动端, 视口大小并不等于窗口大小, 移动端视口宽度被人为定义为了980\n为什么移动端视口宽度是980而不是其他的值\n因为过去网页的版心都是980的，为了能够让网页在移动端完美的展示, 所以将手机视口的大小定义为了980。\n移动端自动将视口宽度设置为980带来的问题\n虽然移动端自动将视口宽度设置为980之后让我们可以很完美的看到整个网页，但是由于移动端的物理尺寸(设备宽度)是远远小于视口宽度的，所以为了能够在较小的范围内看到视口中所有的内容, 那么就必须将内容缩小。\n但是缩小后用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。\n如何保证在移动端不自动缩放网页的尺寸\n通过meta设置视口大小\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\nviewport 是指 web 页面上用户的可视区域。\nmeta标签的属性:\nwidth=device-width 设置视口宽度等于设备的宽度\ninitial-scale=1.0 初始缩放比例, 1不缩放\nmaximum-scale：允许用户缩放到的最大比例\nminimum-scale：允许用户缩放到的最小比例\nuser-scalable：用户是否可以手动缩放","category":"highFrequency","title":"meta viewport 是做什么用的"},{"ansysis":".clearfix:after { \n    /*生成内容作为最后一个元素*/ \n    content: \"\"; \n    /*使生成的元素以块级元素显示,占满剩余空间*/ \n    display: block; \n    /*避免生成内容破坏原有布局的高度*/ \n    height: 0; \n    /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/ \n    visibility: hidden; \n    /*清除浮动元素对当前元素的影响*/ \n    clear: both; \n} \n.clearfix { \n    /*用于兼容IE, 触发IE hasLayout*/ \n    *zoom:1; \n}\n","category":"highFrequency","title":"清除浮动"},{"ansysis":"Scss其实是Sass的改进版本\nScss是Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此Sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。\n\n\nLess环境较Sass简单\nSass的安装需要安装Ruby环境，Less基于JavaScript，需要引入Less.js来处理代码输出css\n\n\n变量符不一样，Less是@，而Sass是$，而且变量的作用域也不一样。\nSass没有局部变量，满足就近原则。Less中{}内定义的变量为局部变量。\n\n\nLess没有输出设置，Sass提供4中输出选项\n输出样式的风格可以有四种选择，默认为nested\nnested：嵌套缩进的css代码\nexpanded：展开的多行css代码\ncompact：简洁格式的css代码\ncompressed：压缩后的css代码\n\n\nSass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。\n\n\nLess与Sass处理机制不一样\nLess是通过客户端处理的，Sass是通过服务端处理，相比较之下Less解析会比Sass慢一点\n\n\nSass和Less的工具库不同\nSass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在     它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。\nLess有UI组件库Bootstrap, Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写，不过Bootstrap4也开始用Sass编写了。","category":"highFrequency","title":" Less/Sass/Scss的区别"},{"ansysis":"BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响，它属于定位方案的普通流。\n触发条件：\n\n根元素\n浮动元素：float 除 none 以外的值（left、right）\n绝对定位元素：position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n约束规则：\n\n属于同一个 BFC 的两个相邻 Box 垂直排列\n属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\nBFC 的区域不会与 float 的元素区域重叠\n计算 BFC 的高度时，浮动子元素也参与计算\n文字层不会被浮动层覆盖，会环绕于周围\n\n作用：\n\n阻止元素被浮动元素覆盖\n一个正常文档流的块级元素可能被一个浮动元素覆盖，挤占正常文档流，因此可以设置一个元素的float、display、position或者overflow值等方式触发BFC，以阻止被浮动盒子覆盖。\n可以包含浮动元素（清除浮动）\n通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。\n阻止相邻元素的margin合并\n属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。\n","category":"highFrequency","title":"BFC及其应用"},{"ansysis":"子绝父相 + transform\n\n.parent {\n    position: relative;\n}\n\n.son {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n}\n\n\n伸缩布局\n\n.parent {\n    display:flex;\n    justify-content:center;\n    align-items: center;\n}\n","category":"highFrequency","title":"水平垂直居中"},{"ansysis":"闭包的实质是因为函数嵌套而形成的作用域链\n比如说：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包\n用途：使用闭包主要是为了设计私有的方法和变量\n优点：可以避免变量被全局变量污染\n缺点：函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包\n解决方法：在退出函数之前，将不使用的局部变量全部删除\n\n还需要了解闭包的使用场景\n","category":"highFrequency","title":"什么是闭包?"},{"ansysis":"选择排序\n\nlet arr = [3, 4, 1, 2];\nlet len = arr.length;\n//  这里之所以是len-1，是因为到最后两个元素，交换位置，整个数组就已经排好序了。\nfor(let i = 0; i < len - 1; i++){\n    let min = arr[i];\n    // j = i+1是把与自己比较的情况给省略掉\n    for(let j = i+1; j < len; j++){\n        if(arr[j] < min){\n            // 利用ES6数组的解构赋值交换数据\n            [arr[j], min] = [min, arr[j]];\n        }\n    }\n    arr[i] = min;\n}\nconsole.log(arr);\n\n\n冒泡排序\n\nlet arr = [3, 4, 1, 2];\nlet max = arr.length - 1;\nfor(let i = 0; i < max; i++){\n    // 声明一个变量，作为标志位\n    // 如果某次循环完后，没有任何两数进行交换，就将标志位设置为 true，表示排序完成\n    let flag = true;\n    for(let j = 0; j < max - i; j++){\n        if(arr[j] > arr[j + 1]){\n            // 利用ES6数组的解构赋值交换数据\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            flag = false;\n        }\n    }\n    if(flag){\n        break;\n    }\n}\nconsole.log(arr);\n","category":"highFrequency","title":"手写选择排序和冒泡排序"},{"ansysis":"数组去重\n方法 1\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员\n// 去除数组的重复成员\n[...new Set([1, 2, 2, 3, 4, 5, 5])];\n// [1, 2, 3, 4, 5]\n\n方法 2\nArray.from()能把set结构转换为数组\nArray.from(new Set([1, 2, 2, 3, 4, 5, 5]));\n// [1, 2, 3, 4, 5]\n\n方法 3（ES5）\nfunction unique(arr) {\n  let temp = [];\n  arr.forEach(e => {\n    if (temp.indexOf(e) == -1) {\n      temp.push(e);\n    }\n  });\n\n  return temp;\n}\n\n反转数组\n要求\n输入: I am a student  输出: student a am I\n输入是数组 输出也是数组 不允许用 split splice reverse\n解法一\nfunction reverseArray(arr) {\n    let str = arr.join(' ')\n    let result = []\n    let word = ''\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] != ' ') {\n            word += str[i]\n        } else {\n            result.unshift(word)\n            word = ''\n        }\n    }\n    \n    result.unshift(word)\n    return result\n}\n\nconsole.log(reverseArray(['I', 'am', 'a', 'student']))\n// [\"student\", \"a\", \"am\", \"I\"]\n\n解法二\nfunction reverseArray(arr) {\n    let result = []\n    let distance = arr.length - 1\n    for (let i = 0; i <= distance; i++) {\n        result[i] = arr[distance - i]\n    }\n\n    return result\n}","category":"highFrequency","title":"数组去重和反转数组"},{"ansysis":"函数节流\n函数节流是优化高频率执行js代码的一种手段\n可以减少高频调用函数的执行次数\n函数防抖\n函数防抖是也优化高频率执行js代码的一种手段\n可以让被调用的函数在一次连续的高频操作中只被调用一次\n\n作用：减少代码执行次数, 提升网页性能\n应用场景：oninput / onmousemove / onscroll / onresize 等事件\n函数节流和函数防抖区别\n函数节流是减少连续的高频操作函数执行次数 (例如连续调用10次, 可能只执行3-4次)\n函数防抖是让连续的高频操作时函数只执行一次(例如连续调用10次, 但是只会执行1次)\n\n函数实现","category":"highFrequency","title":"函数节流和函数防抖"},{"ansysis":"每个\"构造函数\"中都有一个默认的属性, 叫做 prototype, prototype属性保存着一个对象, 这个对象我们称之为\"原型对象\", prototype 指向它的原型对象\n每个\"原型对象\"中都有一个默认的属性, 叫做constructor, constructor 指向当前原型对象对应的那个\"构造函数\"\n通过构造函数创建出来的对象我们称之为\"实例对象\", 每个\"实例对象\"中都有一个默认的属性, 叫做__proto__, __proto__ 指向创建它的那个构造函数的\"原型对象\"\n基本关系\n  1. 所有函数都是Function构造函数的实例对象\n  2. 所有函数都是对象, 包括Function构造函数\n  3. 所有对象都有__proto__属性\n  4. 普通对象的__proto__属性指向创建它的那个构造函数对应的\"原型对象\"\n\n特殊关系\n   5. 所有对象的__proto__属性最终都会指向\"Object原型对象\"\n   6. \"Object原型对象\"的__proto__属性指向NULL\n\n对象中__proto__组成的链条我们称之为原型链\n对象在查找属性和方法的时候, 会先在当前对象查找, 如果有就用自己的\n如果当前对象中找不到想要的, 会依次去上一级原型对象中查找\n如果找到Object原型对象都没有找到, 就会报错\n","category":"highFrequency","title":"原型和原型链"},{"ansysis":"ew一个对象的四个过程：\n1、创建一个空对象\nlet obj = {};\n\n2、让构造函数中的this指向新对象，并执行构造函数的函数体\nlet result = Person.call(obj);\n\n3、设置新对象的__proto__属性指向构造函数的原型对象\nobj.__proto__ = Person.prototype;\n\n4、判断构造函数的返回值类型，如果是值类型，则返回新对象。如果是引用类型，就返回这个引用类型的对象。\n\nif (typeof(result) == \"object\") \n    p = result;\nelse \n    p = obj;\n","category":"highFrequency","title":"new一个对象的时候发生了什么?"},{"ansysis":"ES5继承\n\n在子类中通过call / apply方法借助父类的构造函数\n将子类的原型函数设置为父类的实例对象\nES6继承\n\n通过子类extends父类, 来告诉浏览器子类要继承父类\n通过super()方法修改 this","category":"highFrequency","title":"ES5继承和ES6继承"},{"ansysis":"深拷贝\n修改新变量的值不会影响原有变量的值\n默认情况下基本数据类型都是深拷贝\n\n浅拷贝\n修改新变量的值会影响原有变量的值\n默认情况下引用类型都是浅拷贝\n\n通过自定义函数实现深拷贝，具体代码请自行查找～","category":"highFrequency","title":"深拷贝和浅拷贝，以及如何实现对象深拷贝"},{"title":"进程和线程的区别","ansysis":"进程是程序的一次执行过程，是一个动态概念，是操作系统资源分配的基本单位\n线程是任务调度和执行的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源\n\n一个程序至少有一个进程,一个进程至少有一个线程\n线程的划分尺度小于进程，使得多线程程序的并发性高\n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率\n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制\n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别","category":"highFrequency"},{"ansysis":"JS是单线程的\n所以JS中的代码都是串行的, 前面没有执行完毕后面不能执行\nJavaScript的单线程，与它的用途有关。\n作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。\n这决定了它只能是单线程，否则会带来很复杂的同步问题。\n例如: 如果JS是多线程的\n现在有一个线程要修改元素中的内容, 一个线程要删除该元素, 这时浏览器不知道以哪个线程为准\n除了\"事件绑定的函数\"和\"回调函数\"以外的都是同步代码\n程序运行会从上至下依次执行所有的同步代码\n在执行的过程中如果遇到异步代码会将异步代码放到事件循环中\n当所有同步代码都执行完毕后, JS会不断检测 事件循环中的异步代码是否满足条件\n一旦满足条件就执行满足条件的异步代码\n开发中为了保存异步代码的执行顺序, 那么就会出现回调函数层层嵌套\n如果回调函数嵌套的层数太多, 就会导致代码的阅读性, 可维护性大大降低\npromise是ES6中新增的异步编程解决方案, 在代码中的表现是一个对象\npromise对象可以将异步操作以同步流程来表示, 避免了回调函数层层嵌套问题，避免了回调地狱问题\n","category":"highFrequency","title":"说一下JS异步编程"},{"ansysis":"promise是ES6中新增的异步编程解决方案, 在代码中的表现是一个对象\n开发中为了保存异步代码的执行顺序, 那么就会出现回调函数层层嵌套\n如果回调函数嵌套的层数太多, 就会导致代码的阅读性, 可维护性大大降低\npromise对象可以将异步操作以同步流程来表示, 避免了回调函数层层嵌套问题，避免了回调地狱问题\n我们可以通过 new Promise(function(resolve, reject){}); 来创建一个promise对象，但创建的promise对象不是异步的, 只要创建promise对象就会立即执行存放的代码\npromise对象是通过状态的改变来实现通过同步的流程来表示异步的操作的, 只要状态发生改变就会自动触发对应的函数\nPromise对象有三种状态，分别是\npending:   默认状态，只要没有告诉promise任务是成功还是失败就是pending状态  \nfulfilled(resolved): 只要调用resolve函数, 状态就会变为fulfilled, 表示操作成功  \nrejected:  只要调用rejected函数, 状态就会变为rejected, 表示操作失败  \n\n状态一旦改变既不可逆, 从pending变为fulfilled, 那么永远都是fulfilled，从pending变为rejected, 那么永远都是rejected\n可以通过函数来监听Promise状态的变化\n成功执行  then() 函数的回调\n失败执行  catch() 函数的回调\nPromise的then方法\nthen方法接收两个参数,\n第一个参数是状态切换为成功时的回调,\n第二个参数是状态切换为失败时的回调\nPromise的catch方法\ncatch 其实是 then(undefined, () => {}) 的语法糖\nPromise的all静态方法:\n1.all方法接收一个数组,\n2.如果数组中有多个Promise对象,只有都成功才会执行then方法,  并且会按照添加的顺序, 将所有成功的结果重新打包到一个数组中返回给我们\n3.如果数组中不是Promise对象, 那么会直接执行then方法\n应用场景: 批量加载, 要么一起成功, 要么一起失败\nPromise的race静态方法:\n1.race方法接收一个数组,\n2.如果数组中有多个Promise对象, 谁先返回状态就听谁的, 后返回的会被抛弃\n3.如果数组中不是Promise对象, 那么会直接执行race方法\n应用场景: 接口调试, 超时处理\n","category":"highFrequency","title":"什么是promise"},{"ansysis":"跨域是相对于同源策略而言的。\n同源策略是一种约定，它是浏览器最核心也最基本的安全功能\n所谓同源是指: 协议，域名，端口都相同,就是同源, 否则就是跨域\n同源策略带来的影响\n在同源策略下, 浏览器只允许Ajax请求同源的数据, 不允许请求不同源的数据\n但在企业开发中, 一般情况下为了提升网页的性能, 网页和数据都是单独存储在不同服务器上的\n这时如果再通过Ajax请求数据就会拿不到跨域数据\n跨域解决方案\n可以使用 jsonp\nJSONP让网页从跨域的地址那获取资料，即跨域读取数据","category":"highFrequency","title":"什么是跨域，以及如何解决跨域问题？"},{"ansysis":"HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头\nHTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密\nHTTP 的端口号是 80，HTTPS 是 443\nHTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费\nHTTP 的连接很简单，是无状态的；\nHTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n","category":"highFrequency","title":"HTTP和HTTPS的区别"},{"ansysis":"100-199 用于指定客户端应响应的某些动作\n200-299 用于表示请求成功\n300-399 用于已重定向的文件\n400-499 用于指出客户端的错误\n400：语义有误，当前请求无法被服务器理解\n401：当前请求需要用户验证\n403：服务器已经理解请求，但是拒绝执行它\n404：请求的内容不存在。\n500-599 用于指出服务器错误\n503：服务不可用","category":"highFrequency","title":"HTTP的状态码说一下"},{"ansysis":"提交数据存储位置不同\n\nGET请求会将数据放到URL后面\nPOST请求会将数据放到请求体中\n\n对提交的数据大小限制不同\n\nGET请求对所发信息量的限制是2000 个字符\nPOST请求对信息量没有限制\n\n对提交的数据编码不同\n\nGET请求的参数只能是ASCII码，所以中文需要URL编码\nPOST请求传参没有这个限制\n\n应用场景不同\n\nGET请求用于提交非敏感数据和小数据\nPOST请求用于提交敏感数据和大数据\n\nget请求可以被缓存，post不可以被缓存\nget后退不会有影响，post后退会重新进行提交\nget请求的记录会留在历史记录中，post请求不会留在历史记录\n","category":"highFrequency","title":"get和post的区别"},{"title":"Cookie、SessionStronge、LocalStronge的区别","ansysis":"在同一浏览器下生命周期不同\n\nCookie生命周期:         默认是关闭浏览器后失效, 但是也可以设置过期时间\nSessionStorage生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间\nLocalStorage生命周期:   除非被清除，否则永久保存\n\n容量不同\n\nCookie容量限制:         大小(4KB左右)和个数(20~50)\nSessionStorage和LocalStorage容量限制: 大小(5M左右)\n\n网络请求不同\n\nCookie网络请求:         每次都会携带在HTTP请求头中，如果使用cookie保存过多数据会带来性能问题\nSessionStorage和LocalStorage网络请求: 仅在浏览器中保存，不参与和服务器的通信\n\n应用场景不同\n\nCookie:         判断用户是否登录\nsessionStorage: 表单数据\nLocalStorage:   购物车\n\n需要注意的是：无论通过哪种方式存储的数据, 都不能将敏感数据直接存储到本地\n","category":"highFrequency"},{"ansysis":"ajax简单来说是通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。\najax的优点\n\n最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。\n使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。\n可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求。\n基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。\n\najax的缺点\n\najax对浏览器后退机制造成了破坏，也就是说用户无法通过浏览器的后退按钮回到前一次操作的页面。虽然有些浏览器解决了这个问题，但它也并不能改变ajax的机制，它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。\n安全问题。技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。\n对搜索引擎的支持比较弱。\n破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。\n另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。\n一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的。\n\najax的四个步骤\n\n创建一个异步对象\n\nlet xmlhttp = new XMLHttpRequest();\n\n\n设置请求方式和请求地址\n\nopen(method,url,async)  规定请求的类型、URL 以及是否异步处理请求。\nmethod：请求的类型；GET 或 POST\nurl：文件在服务器上的位置\nasync：true（异步）或 false（同步）\nxmlhttp.open(\"GET\",\"04-ajax-get.php\",true);\n\n\n发送请求\n\nxmlhttp.send();\n\n\n监听状态的变化\n","category":"highFrequency","title":"Ajax的优缺点和四个步骤"},{"category":"highFrequency","title":"前端对后端返回的数据如何处理","ansysis":"前端通过javascript对后端返回的json或者xml进行格式化处理\nJSON:\nvar jsonObj = JSON.parse(后端返回的json字符串);\nvar result = JSON.stringify(jsonObj, null, 2);//格式化\n\nXML：\n先使用 xml2json转化为JSON格式，然后再JSON.parse再JSON.stringfy进行格式化\n"},{"ansysis":"这是一个前端面试非常经典的面试题，这个题目很深，涉及的知识点很广，我这里只是简单概括，如果想进一步了解，可自行搜索\n1. 浏览器会进行DNS域名解析，拿到域名对应的服务器ip地址，再用该ip去访问web服务器\n2. 然后会和web服务器进行tcp的三次握手建立tcp连接\n3. 连接建立成功后，浏览器会发送http的get请求\n4. 服务器收到请求并给予响应，返回请求的数据\n5. 浏览器拿到数据并进行解析、渲染\n6. 浏览器和服务器进行tcp的四次挥手，断开连接\n","category":"highFrequency","title":" 从输入 URL 到页面加载完成的过程中都发生了什么(重点)"},{"ansysis":"三次握手\n\n\n第一次握手(SYN=1, seq=x):\n\n\n客户端发送一个 TCP的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口(请求同步)，并选择序号 seq=x，表明传送数据时的第一个数据字节的序号是 x。(seq是个随机值)\n发送完毕后，客户端进入 SYN_SEND 状态。\n\n\n\n\n第二次握手(SYN=1, ACK=1, seq=y, ack=x+1):\n\n\n服务器的TCP收到连接请求报文段后，如同意，则发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号(随机值y)，放到seq 域里，同时将确认序号ack设置为客户的 ISN 加1，即 x+1(即回复对方确认收到了序列号为x开始的包，且希望下次的数据从x+1的位置开始)。\n发送完毕后，服务器端进入 SYN_RCVD 状态。\n\n\n\n\n第三次握手(ACK=1，ack=y+1，seq=x+1)\n\n\n客户端收到此报文段后再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段ack中发送给对方，并且告诉服务器自己的seq=x+1\n发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP握手结束。\n\n\n\n\n四次挥手\n1.第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。\n2.第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态。\n3.第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态。\n4.第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1， 服务端进入CLOSED状态，完成四次挥手\n","category":"highFrequency","title":"详细说一下 TCP 的三次握手和四次挥手过程(重点)"},{"ansysis":"1.解析HTML生成DOM树  \n2.解析CSS生成CSSOM规则树  \n3.将DOM树和CSSOM规则树合并在一起生成渲染树  \n4.遍历渲染树开始布局，计算每个节点的位置大小信息  \n5.将渲染树的每个节点绘制到屏幕","category":"highFrequency","title":"说一下浏览器渲染机制"},{"ansysis":"1.JS是单线程的\n  JS中的代码都是串行的, 前面没有执行完毕后面不能执行\n\n2.执行顺序\n2.1程序运行会从上至下依次执行所有的同步代码\n2.2在执行的过程中如果遇到异步代码会将异步代码放到事件循环中\n2.3当所有同步代码都执行完毕后, JS会不断检测 事件循环中的异步代码是否满足条件\n2.4一旦满足条件就执行满足条件的异步代码\n\n3.宏任务和微任务\n在JS的异步代码中又区分\"宏任务(MacroTask)\"和\"微任务(MicroTask)\"\n宏任务: 宏/大的意思, 可以理解为比较费时比较慢的任务\n微任务: 微/小的意思, 可以理解为相对没那么费时没那么慢的任务\n\n4.常见的宏任务和微任务\nMacroTask: setTimeout, setInterval, setImmediate（IE独有）...\nMicroTask: Promise, MutationObserver ,process.nextTick（node独有) ...\n注意点: 所有的宏任务和微任务都会放到自己的执行队列中, 也就是有一个宏任务队列和一个微任务队列\n        所有放到队列中的任务都采用\"先进先出原则\", 也就是多个任务同时满足条件, 那么会先执行先放进去的\n\n5.完整执行顺序\n1.从上至下执行所有同步代码\n2.在执行过程中遇到宏任务就放到宏任务队列中,遇到微任务就放到微任务队列中\n3.当所有同步代码执行完毕之后, 就执行微任务队列中满足需求所有回调\n4.当微任务队列所有满足需求回调执行完毕之后, 就执行宏任务队列中满足需求所有回调\n... ...\n注意点:\n每执行完一个宏任务都会立刻检查微任务队列有没有被清空, 如果没有就立刻清空\n","category":"highFrequency","title":"说一下浏览器事件环"}]}
{"_id":"a573b43362c04fbf0000b3003638bfd5","keyWord":"css","css":[{"title":"实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。","category":"css","ansysis":"<div style=\"height:1px;overflow:hidden;background:red\"></div>"},{"title":"介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？","category":"css","ansysis":"参考答案：\n\n（1）有两种， IE 盒子模型、W3C 盒子模型；\n\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n\n（3）区 别： IE 的 content 部分把 border 和 padding 计算了进去;\n\n相关知识点：\n\n（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）\n（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分\n\nIE盒模型和W3C标准盒模型的区别：\n\n（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding\n（2）IE盒模型：属性width，height包含content、border和padding，指的是content\n+padding+border。\n\n在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；\n如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE\n盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。\n回答：\n\n盒模型都是由四个部分组成的，分别是margin、border、padding和content。\n\n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的\n范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。\n\n一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型"},{"title":"CSS 隐藏元素的几种方法（至少说出三种）","category":"css","ansysis":"参考答案：\n\nOpacity: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;\n\nVisibility: 与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;\n\nDisplay:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;\n\nPosition: 不会影响布局，能让元素保持可以操作;\n\nClip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低"},{"title":"CSS 清除浮动的几种方法（至少两种）","category":"css","ansysis":"参考答案：\n\n清除浮动： 核心：clear:both;\n\n1.使用额外标签法（不推荐使用）\n\n在浮动的盒子下面再放一个标签，使用 clear:both;来清除浮动\n\na 内部标签：会将父盒子的高度重新撑开\n\nb 外部标签：只能将浮动盒子的影响清除，但是不会撑开盒子\n\n2.使用 overflow 清除浮动（不推荐使用）\n\n先找到浮动盒子的父元素，给父元素添加一个属性：overflow:hidden;就会清除子元素对页面的影响\n\n3.使用伪元素清除浮动(用的最多)\n\n伪元素：在页面上不存在的元素，但是可以通过 css 添加上去\n\n种类：\n      :after(在。。。之后)\n      :before(在。。。之前)\n\n注意：每个元素都有自己的伪元素\n\n.clearfix:after {\n    content:\"\";\n    height:0;\n    line-height:0;\n    display:block;\n    clear:both;\n    visibility:hidden;  /_将元素隐藏起来_/ \n      在页面的 clearfix 元素后面添加了一个空的块级元素\n     （这个元素的高为 0 行高也为 0   并且这个元素清除了浮动）\n}\n.clearfix {\n  zoom:1;/_为了兼容 IE6_/\n}"},{"title":"页面导入样式时，使用 link 和@import 有什么区别？","category":"css","ansysis":"参考答案：\n\n1. Link 属于 html 标签，而@import 是 CSS 中提供的\n\n2. 在页面加载的时候，link 会同时被加载，而@import 引用的 CSS 会在页面加载完成后才会加载引用的 CSS\n\n3. @import 只有在 ie5 以上才可以被识别，而 link 是 html 标签，不存在浏览器兼容性问题\n\n4. Link 引入样式的权重大于@import 的引用（@import 是将引用的样式导入到当前的页面中）"},{"title":" 伪元素和伪类的区别？","category":"css","ansysis":"参考答案：\n\n1、伪元素使用 2 个冒号，常见的有：::before，::after，::first-line，::first-letter，::selection、::placeholder 等；\n\n  伪类使用1个冒号，常见的有：:hover，:link，:active，:target，:not()，:focus等。\n2、伪元素添加了一个页面中没有的元素（只是从视觉效果上添加了，不是在文档树中添加）；\n\n  伪类是给页面中已经存在的元素添加一个类。\n解析：\n\nCSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（ :first-line ， :first-letter ）或将元素添加到标记中（与 content:... 组合），而不必修改标记（ :before ， :after ）。\n\n:first-line 和 :first-letter 可以用来修饰文字。\n上面提到的 .clearfix 方法中，使用 clear: both 来添加不占空间的元素。\n使用 :before 和 after 展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的"},{"title":"CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有那些？","category":"css","ansysis":"参考答案：\n\n\n（1）id选择器（#myid）\n（2）类选择器（.myclassname）\n（3）标签选择器（div,h1,p）\n（4）后代选择器（h1 p）\n（5）相邻后代选择器（子）选择器（ul>li）\n（6）兄弟选择器（li~a）\n（7）相邻兄弟选择器（li+a）\n（8）属性选择器（a[rel=\"external\"]）\n（9）伪类选择器（a:hover,li:nth-child）\n（10）伪元素选择器（::before、::after）\n（11）通配符选择器（*）\n\n * 继承： font-size font-family color, UL LI DL DD DT;\n\n * 不可继承 ：border padding margin width height ;\n\n * 优先级就近原则，样式定义最近者为准;\n\n * 载入样式以最后载入的定位为准;\n\n优先级为:\n\n       !important >  id > class > tag  \n\n       important 比 内联优先级高\n\nCSS3新增伪类举例：\n\n    p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n\n    p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\n    p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n\n    p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。\n\n    p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n    :enabled、:disabled 控制表单控件的禁用状态。\n\n    :checked，单选框或复选框被选中。"},{"title":"行内元素和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？","category":"css","ansysis":"参考答案：\n\n块级元素(block)特性：\n\n总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;\n宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;\n内联元素(inline)特性：\n\n和相邻的内联元素在同一行;\n宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom)和外边距的 top/bottom(margin-top/margin-bottom)都不可改变（也就是 padding 和 margin 的 left 和 right 是可以设置的），就是里面文字或图片的大小。\n那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？\n\n参考答案： <input> 、<img> 、<button> 、<texterea> 、<label>。"},{"title":"什么是外边距重叠？重叠的结果是什么？","category":"css","ansysis":"参考答案：\n\n外边距重叠就是 margin-collapse。\n\n在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n\n折叠结果遵循下列计算规则：\n\n1. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n\n2. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n\n3. 两个外边距一正一负时，折叠结果是两者的相加的和。"},{"title":"rgba()和 opacity 的透明效果有什么不同？","category":"css","ansysis":"参考答案：\n\nrgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度，\n\n而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）"},{"title":"css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？","category":"css","ansysis":"参考答案：\n\n垂直方向：line-height\n\n水平方向：letter-spacing\n\n那么问题来了，关于 letter-spacing 的妙用知道有哪些么？\n\n参考答案: 可以用于消除 inline-block 元素间的换行符空格间隙问题。"},{"title":"px 和 em 的区别。","category":"css","ansysis":"参考答案：px 和 em 都是长度单位，区别是，px 的值是固定的，指定是多少就是多少，计算比较容易。em 得值不是固定的，并且 em 会继承父级元素的字体大小。\n\n浏览器的默认字体高都是 16px。所以未经调整的浏览器都符合: 1em=16px。那么 12px=0. 75em, 10px=0. 625em。"},{"title":"如何垂直居中一个元素？","category":"css","ansysis":"参考答案：\n\n方法一：绝对定位居中（原始版之已知元素的高宽）\n\n.content {\n    width: 200px;\n    height: 200px;\n    background-color: #6699ff;\n    position: absolute;\n    /*父元素需要相对定位*/\n    top: 50%;\n    left: 50%;\n    margin-top: -100px;\n    /*设为高度的1/2*/\n    margin-left: -100px;\n    /*设为宽度的1/2*/\n}\n方法二：绝对定位居中（改进版之一未知元素的高宽）\n\n.content {\n    width: 200px;\n    height: 200px;\n    background-color: #6699ff;\n    position: absolute;\n    /*父元素需要相对定位*/\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    /*在水平和垂直方向上各偏移-50%*/\n}\n方法三：绝对定位居中（改进版之二未知元素的高宽）\n\n.content {\n    width: 200px;\n    height: 200px;\n    background-color: #6699ff;\n    margin: auto;\n    /*很关键的一步*/\n    position: absolute;\n    /*父元素需要相对定位*/\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    /*让四个定位属性都为0*/\n}\n方法四：flex 布局居中\n\nbody {\n    display: flex;\n    /*设置外层盒子display为flex*/\n    align-items: center;\n    /*设置内层盒子的垂直居中*/\n    justify-content: center;\n\n    /*设置内层盒子的水平居中*/\n    .content {\n        width: 200px;\n        height: 200px;\n        background-color: #6699ff;\n    }\n}\n那么问题来了，如何垂直居中一个 img（用更简便的方法。）\n\n.content {\n    //img的容器设置如下\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}"},{"title":"什么是BFC？","category":"css","ansysis":"参考答案：\n\n什么是 BFC\n\nBFC（Block Formatting Context）格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。\n\n形成 BFC 的条件\n\n浮动元素，float 除 none 以外的值\n定位元素，position（absolute，fixed）\ndisplay 为以下其中之一的值 inline-block，table-cell，table-caption\noverflow 除了 visible 以外的值（hidden，auto，scroll）\nBFC 的特性\n\n内部的 Box 会在垂直方向上一个接一个的放置。\n垂直方向上的距离由 margin 决定\nbfc 的区域不会与 float 的元素区域重叠。\n计算 bfc 的高度时，浮动元素也参与计算\nbfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。"},{"title":"用纯 CSS 创建一个三角形的原理是什么？","category":"css","ansysis":"参考答案：\n\nspan {\n    width: 0;\n    height: 0;\n    border-top: 40px solid transparent;\n    border-left: 40px solid transparent;\n    border-right: 40px solid transparent;\n    border-bottom: 40px solid #ff0000;\n}"},{"title":"Sass、LESS 是什么？大家为什么要使用他们？","category":"css","ansysis":"参考答案：他们是 CSS 预处理器。他是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。\n\n例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node. js)。\n\n为什么要使用它们？\n\n结构清晰，便于扩展。\n\n可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。\n\n可以轻松实现多重继承。\n\n完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。"},{"title":"display:none 与 visibility:hidden 的区别是什么？","category":"css","ansysis":"参考答案：\n\ndisplay :  隐藏对应的元素但不挤占该元素原来的空间。\n\nvisibility:  隐藏对应的元素并且挤占该元素原来的空间。\n\n即是，使用 CSS display:none 属性后，HTML 元素（对象）的宽度、高度等各种属性值都将“丢失”; 而使用 visibility:hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。"},{"title":"移动端 1px 问题的解决办法","category":"css","ansysis":"参考答案：推荐解决方法：媒体查询 + transfrom\n\n/* 2倍屏 */\n@media only screen and (-webkit-min-device-pixel-ratio: 2.0) {\n    .border-bottom::after {\n        -webkit-transform: scaleY(0.5);\n        transform: scaleY(0.5);\n    }\n}\n/* 3倍屏 */\n@media only screen and (-webkit-min-device-pixel-ratio: 3.0) {\n    .border-bottom::after {\n        -webkit-transform: scaleY(0.33);\n        transform: scaleY(0.33);\n    }\n}"},{"title":"几种常见的 CSS 布局","category":"css","ansysis":"参考答案：\n\n可继承： font-size font-family color, ul li dl dd dt;\n\n不可继承 ：border padding margin width height ;"},{"title":"li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？","category":"css","ansysis":"参考答案：\n\n单列布局\n两列自适应布局\n圣杯布局和双飞翼布局\n伪等高布局\n粘连布局"},{"title":"设置元素浮动后，该元素的 display 值是多少？","category":"css","ansysis":"参考答案：浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab）渲染成一个空格，也就是我们上面的代码\n\n换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。\n解决方案：\n\n方法一：既然是因为 <li> 换行导致的，那就可以将 <li> 代码全部写在一排，如下\n\n<div class=\"wrap\">\n    <h3>li标签空白测试</h3>\n    <ul>\n        <li class=\"part1\"></li>\n        <li class=\"part2\"></li>\n        <li class=\"part3\"></li>\n        <li class=\"part4\"></li>\n    </ul>\n</div>\n方法二：我们为了代码美观以及方便修改，很多时候我们不可能将 <li> 全部写在一排，那怎么办？既然是空格占一个字符的宽度，那我们索性就将 <ul> 内的字符尺寸直接设为 0，将下面样式放入样式表，问题解决。\n\n.wrap ul {\n    font-size: 0px;\n}\n但随着而来的就是 <ul> 中的其他文字就不见了，因为其尺寸被设为 0px 了，我们只好将他们重新设定字符尺寸。 方法三：本来以为方法二能够完全解决问题，但经测试，将 li 父级标签字符设置为 0 在 Safari 浏览器依然出现间隔空白；既然设置字符大小为 0 不行，那咱就将间隔消除了，将下面代码替换方法二的代码，目前测试完美解决。同样随来而来的问题是 li 内的字符间隔也被设置了，我们需要将 li 内的字符间隔设为默认。\n\n.wrap ul {\n    letter-spacing: -5px;\n}\n之后记得设置 li 内字符间隔\n\n.wrap ul li {\n    letter-spacing: normal;\n}"},{"title":"怎么让 Chrome 支持小于 12px 的文字？","category":"css","ansysis":"参考答案：\n\n自动变成 display:block"},{"title":"display:inline-block 什么时候会显示间隙？","category":"css","ansysis":"参考答案：\n\ncss3 的 transform 属性，设置值为 scale(x, y) 定义 2D 缩放转换\n\n示例：\n\n-webkit-transform: scale(0. 50);"},{"title":"png、jpg、gif 这些图片格式解释一下，分别什么时候用？，webp 呢","category":"css","ansysis":"参考答案：间隙产生的原因是因为，换行或空格会占据一定的位置\n\n推荐解决方法：\n\n父元素中设置 font-size:0; letter-spaceing:-4px;"},{"title":"style 标签写在 body 后与 body 前有什么区别？","category":"css","ansysis":"参考答案：\n\n从上向下加载，加载顺序不同"},{"title":"超链接访问过后 hover 样式就不出现的问题是什么？如何解决？","category":"css","ansysis":"参考答案：被点击访问过的超链接样式不在具有 hover 和 active 了, 解决方法是改变 CSS 属性的排列顺序: L-V-H-A（link, visited, hover, active）"},{"title":"什么是 Css Hack？ie6, 7, 8 的 hack 分别是什么？","category":"css","ansysis":"参考答案：针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack。\n\n示例如下：\n\n#test {\n    width: 300px;\n    height: 300px;\n    background-color: blue;/_firefox_/ background-color: red\\9;/_all ie_/ background-color: yellow;/_ie8_/+background-color: pink;/_ie7_/ \\_background-color: orange;/_ie6_/\n}\n\n:root #test {\n    background-color: purple\\9;\n}\n\n/*ie9*/\n\n@media all and (min-width:0px) {\n    #test {\n        background-color: black;\n    }\n}\n\n/*opera*/\n\n@media screen and (-webkit-min-device-pixel-ratio:0) {\n    #test {\n        background-color: gray;\n    }\n}\n"},{"title":"重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？","category":"css","ansysis":"参考答案：\n\n重置（Resetting）： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像 margin 、 padding 、 font-size 这些样式全部置成一样。你将必须重新定义各种元素的样式。\n标准化（Normalizing）： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。\n当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。"},{"title":"css sprite 是什么, 有什么优缺点","category":"css","ansysis":"参考答案：概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。\n\n优点：\n\n减少 HTTP 请求数，极大地提高页面加载速度。\n增加图片信息重复度，提高压缩比，减少图片大小。\n更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现。\n缺点：\n\n图片合并麻烦。\n维护麻烦，修改一个图片可能需要从新布局整个图片，样式。"},{"title":"什么是 FOUC? 如何避免","category":"css","ansysis":"参考答案：\n\n1. 什么是 Fouc(文档样式短暂失效)？\n\n在引用 css 的过程中，如果方法不当或者位置引用不对，会导致某些页面在 windows 下的 ie 出现一些奇怪的现象，以无样式显示页面内容的瞬间闪烁，这种现象称之为文档样式短暂失效，简称 FOCU。\n\n2. 原因大致为：\n\n使用 import 方法导入样式表\n将样式表放在页面底部\n有几个样式表，放在 html 结构的不同位置。\n3. 其实原理很清楚：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。\n\n4. 解决方法：使用 link 标签将样式表放在文档 head 中。"},{"title":"css3 有哪些新特性","category":"css","ansysis":"参考答案：\n\n1. 选择器\n\nE:last-child 匹配父元素的最后一个子元素 E。\nE:nth-child(n)匹配父元素的第 n 个子元素 E。\nE:nth-last-child(n) CSS3 匹配父元素的倒数第 n 个子元素 E。\n2. RGBA\n\n回答此问题，面试官很可能继续问：rgba()和 opacity 的透明效果有什么不同？\n\n3. 多栏布局\n\n<div class=\"mul-col\">\n    <div>\n        <h3>新手上路</h3>\n        <p>新手专区 消费警示 交易安全 24小时在线帮助 免费开店</p>\n    </div>\n    <div>\n        <h3>付款方式</h3>\n        <p>快捷支付 信用卡 余额宝 蚂蚁花呗 货到付款</p>\n    </div>\n    <div>\n        <h3>淘宝特色</h3>\n        <p>手机淘宝 旺信 大众评审 B格指南</p>\n    </div>\n</div>\n.mul-col {\n    column-count: 3;\n    column-gap: 5px;\n    column-rule: 1px solid gray;\n    border-radius: 5px;\n    border: 1px solid gray;\n    padding: 10px;\n}\n4. 多背景图\n\n/* backgroundimage:url('1.jpg),url('2.jpg') */\n5. CSS3 word-wrap 属性\n\np.test {\n    word-wrap: break-word;\n}\n6. 文字阴影\n\ntext-shadow: 5px 2px 6px rgba(64, 64, 64, 0.5);\n7. @font-face 属性\n\nFont-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。\n\n@font-face {\n    font-family: BorderWeb;\n    src: url(BORDERW0.eot);\n}\n\n@font-face {\n    font-family: Runic;\n    src: url(RUNICMT0.eot);\n}\n\n.border {\n    font-size: 35px;\n    color: black;\n    font-family: \"BorderWeb\";\n}\n\n.event {\n    font-size: 110px;\n    color: black;\n    font-family: \"Runic\";\n}\n\n/* 淘宝网字体使用 */\n\n@font-face {\n    font-family: iconfont;\n    src: url(//at.alicdn.com/t/font_1465189805_4518812.eot);\n}\n8. 圆角\n\nborder-radius: 15px;\n9. 边框图片\n\nCSS3 border-image 属性\n\n盒阴影\n/* box-shadow: 水平方向的偏移量 垂直方向的偏移量 模糊程度 扩展程度 颜色 是否具有内阴影 */\n盒子大小\nCSS3 box-sizing 属性\n\n媒体查询\nCSS3 @media 查询\n\nCSS3 动画\n@keyframes\n\n@keyframes abc {\n    from {\n        transform: rotate(0);\n    }\n\n    50% {\n        transform: rotate(90deg);\n    }\n\n    to {\n        transform: rotate(360deg);\n    }\n}\nanimation 属性\n\n/* animation ： name duration timing-function delay interation-count direction play-state */\n渐变效果\nbackground-image: -webkit-gradient(linear,\n    0% 0%,\n    100% 0%,\n    from(#2a8bbe),\n    to(#fe280e));\nCSS3 弹性盒子模型\n弹性盒子是 CSS3 的一种新的布局模式。\nCSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。\n引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。\nCSS3 过渡\ndiv {\n    transition: width 2s;\n    -moz-transition: width 2s;\n    /* Firefox 4 */\n    -webkit-transition: width 2s;\n    /* Safari 和 Chrome */\n    -o-transition: width 2s;\n    /* Opera */\n}\nCSS3 变换\nrotate()旋转\ntranslate()平移\nscale( )缩放\nskew()扭曲/倾斜\n变换基点\n3d 转换"},{"title":"display 有哪些值？说明他们的作用","category":"css","ansysis":"参考答案：\n\ndisplay： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex\n\n解析：\n\n默认值：inline\n\nnone： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间\ninline： 指定对象为内联元素。\nblock： 指定对象为块元素。\nlist-item： 指定对象为列表项目。\ninline-block： 指定对象为内联块元素。（CSS2）\ntable： 指定对象作为块元素级的表格。类同于html标签<table>（CSS2）\ninline-table： 指定对象作为内联元素级的表格。类同于html标签<table>（CSS2）\ntable-caption： 指定对象作为表格标题。类同于html标签<caption>（CSS2）\ntable-cell： 指定对象作为表格单元格。类同于html标签<td>（CSS2）\ntable-row： 指定对象作为表格行。类同于html标签<tr>（CSS2）\ntable-row-group： 指定对象作为表格行组。类同于html标签<tbody>（CSS2）\ntable-column： 指定对象作为表格列。类同于html标签<col>（CSS2）\ntable-column-group： 指定对象作为表格列组显示。类同于html标签<colgroup>（CSS2）\ntable-header-group： 指定对象作为表格标题组。类同于html标签<thead>（CSS2）\ntable-footer-group： 指定对象作为表格脚注组。类同于html标签<tfoot>（CSS2）\nrun-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3）\nbox： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）\ninline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）\nflexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）\ninline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）\nflex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）\ninline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）"},{"title":" display:inline-block 什么时候不会显示间隙？","category":"css","ansysis":"参考答案：inline-block 布局的元素在编辑器里写在同一行"},{"title":"PNG, GIF, JPG 的区别及如何选","category":"css","ansysis":"参考答案：\n\nGIF：\n\n1：256 色\n2： 无损，编辑 保存时候，不会损失。\n3：支持简单动画。\n4：支持 boolean 透明，也就是要么完全透明，要么不透明\nJPEG：\n\n1：millions of colors\n2： 有损压缩， 意味着每次编辑都会失去质量。\n3：不支持透明。\n4：适合照片，实际上很多相机使用的都是这个格式。\nPNG：\n\n1：无损，其实 PNG 有好几种格式的，一般分为两类：PNG8 和 truecolor PNGs；\n\n与 GIF 相比：\n\n它通常会产生较小的文件大小。\n它支持阿尔法（变量）透明度。\n无动画支持\n与 JPEG 相比：\n\n文件更大\n无损\n因此可以作为 JPEG 图片中间编辑的中转格式。\n结论：\n\nJPEG 适合照片\nGIF 适合动画\nPNG 适合其他任何种类——图表，buttons，背景，图表等等。"},{"title":"行内元素 float:left 后是否变为块级元素？","category":"css","ansysis":"参考答案：\n\n行内元素设置成浮动之后变得更加像是 inline-block\n行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100%，行内元素默认 100%宽度占据一行\n这时候给行内元素设置 padding-top 和 padding-bottom 或者 width、height 都是有效果的"},{"title":" 在网页中的应该使用奇数还是偶数的字体？为什么呢？","category":"css","ansysis":"参考答案：应该使用偶数字体\n\n1. 比例关系\n\n相对来说偶数字号比较容易和页面中其他部分的字号构成一个比例关系。如我使用 14px 的字体作为正文字号，那么其他部分的字体（如标题）就可以使用 14×1. 5 =21px 的字体，或者在一些地方使用到了 14×0. 5=7px 的 padding 或者 margin，如果你是在用 sass 或者 less 编写 css，这时候用处就凸显出来了。\n\n2. UI 设计师的缘故\n\n大多数设计师用的软件如 ps 提供的字号是偶数，自然到了   前端那边也是用的是偶数。\n\n3. 浏览器缘故\n\n其一是低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。\n\n其二是为了平分字体。偶数宽的汉字，如 12px 的汉子，去掉 1 像素的字体间距，填充了的字体像素宽度其实就是 11px，这样的汉字中竖线左右是平分的，如“中”子，左右就是 5px 了。\n\n4. 系统差别\n\nWindows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。\n\n而在 Linux 和其他手持设备上，奇数偶数的渲染效果其实相差不大。"},{"title":"CSS 合并方法","category":"css","ansysis":"参考答案：@import url(css 文件地址)"},{"title":"列出你所知道可以改变页面布局的属性","category":"css","ansysis":"参考答案：width、height、float、position、等"},{"title":"CSS 在性能优化方面的实践","category":"css","ansysis":"参考答案：\n\n1. 内联首屏关键 CSS（Critical CSS）\n\n内联 CSS 能够使浏览器开始页面渲染的时间提前，只将渲染首屏内容所需的关键 CSS 内联到 HTML 中\n\n2. 异步加载 CSS\n\n3. 文件压缩\n\n4. 去除无用 CSS"},{"title":" CSS3 动画（简单动画的实现，如旋转等）","category":"css","ansysis":"参考答案：\n\n让一个 div 元素旋转 360 度示例\n\n1. div 的样式结构:\n\ndiv {\n    margin: 50px auto;\n    width: 200px;\n    height: 200px;\n    background-color: pink;\n}\n2. 设置旋转属性的类名:\n\ndiv.rotate {\n    /* 旋转360度 */\n    transform: rotate(360deg);\n    /* all表示所有属性,1s表示在一秒的时间完成动画 */\n    transition: all 1s;\n}\ntransition 有四个属性:\n\nproperty: 规定应用过渡的 CSS 属性的名称。\n\nduration: 定义过渡效果花费的时间。默认是 0,单位是 s。\n\ntiming-function: 规定过渡效果的时间曲线。默认是 \"ease\"。匀速'linear',加速'ease-in',减速'ease-out',先快后慢'ease-in-out'。\n\ndelay: 规定过渡效果何时开始。默认是 0。单位 s。\n\n可以连写: transition: property duration timing-function delay;\n3. 给 div 元素设置鼠标移入时旋转, 也就是给它加上. rotate 类名. 鼠标移出时移除类名\n\n$(function() {\n    $(\"div\")\n        .mouseenter(function() {\n            $(this).addClass(\"rotate\");\n        })\n        .mouseleave(function() {\n            $(this).removeClass(\"rotate\");\n        });\n});"},{"title":" base64 的原理及优缺点","category":"css","ansysis":"参考答案：\n\n1. 什么是 Base64\n\nBase64 是一种基于 64 个可打印字符来表示二进制数据的编码方式，是从二进制数据到字符的过程。 原则上，计算机中所有内容都是二进制形式存储的，所以所有内容（包括文本、影音、图片等）都可以用 base64 来表示。\n\n2. 适用场景\n\n1.Base64一般用于在HTTP协议下传输二进制数据，由于HTTP协议是文本协议，所以在HTTP写一下传输二进制数据需要将二进制数据转化为字符数据，\n网络传输只能传输可打印字符，\n在ASCII码中规定，0-31、128这33个字符属于控制字符，\n32~127这95个字符属于可打印字符\n那么其它字符怎么传输呢，Base64就是其中一种方式，\n2.将图片等资源文件以Base64编码形式直接放于代码中，使用的时候反Base64后转换成Image对象使用。\n3.偶尔需要用这条纯文本通道传一张图片之类的情况发生的时候，就会用到Base64，比如多功能Internet 邮件扩充服务（MIME）就是用Base64对邮件的附件进行编码的。\n3. Base64 编码原理\n\nBase64 编码之所以称为 Base64，是因为其使用 64 个字符来对任意数据进行编码，同理有 Base32、Base16 编码。标准 Base64 编码使用的 64 个字符\n\n有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64 编码又有很多变种，比如用于编码 URL 的 Base64 URL 编码。\n\nBase64 编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续 6 比特（2 的 6 次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。\n\n假设我们要对 Hello! 进行 Base64 编码，按照 ASCII 表，可知 Hello! 的 Base64 编码结果为 SGVsbG8h，每 3 个原始字符经 Base64 编码成 4 个字符。那么，当原始字符串长度不能被 3 整除时，怎么办呢？\n\n以 Hello!! 为例，Base64 编码的结果为 SGVsbG8hIQAA。可见，不能被 3 整除时会采用来来补 0 的方式来完成编码。 需要注意的是：标准 Base64 编码通常用 = 字符来替换最后的 A，即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在 Base64 编码索引表中，其意义在于结束符号，在 Base64 解码时遇到 = 时即可知道一个 Base64 编码字符串结束。\n\n4. 优缺点\n\n优点: 可以将二进制数据转化为可打印字符，方便传输数据，对数据进行简单的加密，肉眼安全。 缺点：内容编码后体积变大，编码和解码需要额外工作量。"},{"title":"stylus/sass/less 区别","category":"css","ansysis":"参考答案：\n\n1. 后缀\n\n默认 Sass 使用 . sass 扩展名，而 Less 使用 . less 扩展名，Stylus 默认使用 . styl 的文件扩展名\n\n2. 语法\n\n3. 变量\n\nsass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和 css 属性是一样的\nLess css 中变量都是用@开头的，其余与 sass 都是一样的\nstylus 对变量是没有任何设定的，可以是以$开头，或者任何的字符，而且与变量之间可以用冒号，空格隔开，但是在 stylus 中不能用@开头"},{"title":"position 的值， relative 和 absolute 分别是相对于谁进行定位的？","category":"css","ansysis":"参考答案：\n\nabsolute : 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。\nfixed （老 IE 不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。\nrelative 生成相对定位的元素，相对于其在普通流中的位置进行定位。\nstatic 默认值。没有定位，元素出现在正常的流中\nsticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出"},{"title":"对偏移、卷曲、可视的理解","category":"css","ansysis":"偏移\noffsetWidth\t  width  +  padding  +  border\noffsetHeight\theight +  padding  +  border\noffsetLeft\noffsetTop\noffsetParent\n注意：没有offsetRight和offsetBottom\n************************************************************************************************\n\n卷曲\nscrollWidth    width  +  padding\nscrollHeight   当内部的内容溢出盒子的时候， 顶边框的底部，计算到内容的底部；如果内容没有溢出盒子，计算方式为盒子内部的真实高度（边框到边框）\nscrollLeft     这个scroll系列属性不是只读的\nscrollTop\nscroll()\n\n此函数可以获取卷曲的高度和卷曲的宽度\nfunction myScroll() {\n   return {\n      top: window.pageYOffset  || document.documentElement.scrollTop  || document.body.scrollTop  || 0,\n      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0\n    };\n\n}\n\n滚动滚动条的时候触发事件\nbox（window）.onscroll = function () {}\n************************************************************************************************\n\n可视\nclientWidth   获取的是元素内部的真实宽度 width  +  padding\nclientHeight  边框之间的高度\nclientLeft    相当于左边框的宽度  如果元素包含了滚动条，并且滚动条显示在元素的左侧。这时，clientLeft属性会包含滚动条的宽度17px\nclientTop     相当于顶边框的宽度\nclient()\n\n此函数可以获取浏览器可视区域的宽高\nfunction myClient() {\n    return {\n        wid: window.innerWidth  || document.documentElement.clientWidth  || document.body.clientWidth  || 0,\n       heit: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0\n    };\n}\n\n----------------------------------------------------------------------------------------------\n@offsetHeight和style.height的区别\n\ndemo.style.height只能获取行内样式，如果样式写到了其他地方，甚至根本就没写，便无法获取\nstyle.height是字符串（而且带单位），offsetHeight是数值\ndemo.style.height可以设置行内样式，offsetHeight是只读属性\n因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度\n\n----------------------------------------------------------------------------------------------\n@offsetLeft和style.left的区别\n\n一、style.left只能获取行内样式\n二、offsetLeft只读，style.left可读可写\n三、offsetLeft是数值，style.left是字符串并且有单位px\n四、如果没有加定位，style.left获取的数值可能是无效的\n五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准\n\n----------------------------------------------------------------------------------------------\n@scrollHeight和scrollWidth\n\n标签内部实际内容的高度/宽度\n不计算边框，如果内容不超出盒子，值为盒子的宽高（不带边框）\n如果内容超出了盒子，就是从顶部或左部边框内侧一直到内容a的最外部分\n\n----------------------------------------------------------------------------------------------\n@scrollTop和scrollLeft\n\n被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离"},{"title":"精灵图和 base64 如何选择？","category":"css","ansysis":"参考答案：\n\nCss Sprites：\n介绍： Css Sprites（雪碧图或 css 精灵），是网页图片处理的一种方式，它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。\n\n原理： 将许多的小图片整合到一张大图片中，利用 css 中的 background-image 属性，background-position 属性定位某个图片位置，来达到在大图片中引用某个部位的小图片的效果。\n\n优点： 减少网页的 http 请求，提升网页加载速度。 合并多张小图片成大图，能减少字节总数（大图大小<=多张小图大小）.\n\n缺点： 前期需要处理图片将小图合并，多些许工程量。 对于需要经常改变的图片维护起来麻烦。\n\nbase64：\n介绍： base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一，要求把每三个 8Bit 的字节转换为四个 6Bit 的字节，Base64 是网络上最常见的用于传输 8Bit 字节代码的编码方式之一。\n\n通俗点讲：将资源原本二进制形式转成以 64 个字符基本单位，所组成的一串字符串。 比如一张图片转成 base64 编码后就像这样，图片直接以 base64 形式嵌入文件中（很长没截完）\n生成 base64 编码： 图片生成 base64 可以用一些工具，如在线工具，但在项目中这样一个图片这样生成是挺繁琐。 特别说下，webpack 中的 url-loader 可以完成这个工作，可以对限制大小的图片进行 base64 的转换，非常方便。\n\n优点： base64 的图片会随着 html 或者 css 一起下载到浏览器, 减少了请求. 可避免跨域问题\n\n缺点： 老东西（低版本）的 IE 浏览器不兼容。 体积会比原来的图片大一点。 css 中过多使用 base64 图片会使得 css 过大，不利于 css 的加载。\n\n适用场景： 应用于小的图片几 k 的，太大的图片会转换后的大小太大，得不偿失。 用于一些 css sprites 不利处理的小图片，如一些可以通过 background-repeat 平铺来做成背景的图片"},{"title":"如果设计中使用了非标准的字体，你该如何去实现？","category":"css","ansysis":"参考答案：使用 @font-face 并为不同的 font-weight 定义 font-family 。"},{"title":"知道 css 有个 content 属性吗？有什么作用？有什么应用？","category":"css","ansysis":"参考答案：知道。css 的 content 属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。\n\n//一种常见利用伪类清除浮动的代码\n.clearfix:after {\n    content: \".\"; //这里利用到了content属性\n    display: block;\n    height: 0;\n    visibility: hidden;\n    clear: both;\n}\n\n.clearfix {\n    zoom: 1;\n}\nafter 伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用 clear:both 清除浮动。 那么问题继续还有，知道 css 计数器（序列数字字符自动递增）吗？如何通过 css content 属性实现 css 计数器？\n\n参考答案：css 计数器是通过设置 counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合 after / before 伪类实现。"},{"title":"CSS 选择器的优先级是如何计算的？","category":"css","ansysis":"参考答案：浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以 a、b、c、d 命名，分别代表以下含义：\n\n1. a 表示是否使用内联样式（inline style）。如果使用， a 为 1，否则为 0。 2. b 表示 ID 选择器的数量。 3. c 表示类选择器、属性选择器和伪类选择器数量之和。 4. d 表示标签（类型）选择器和伪元素选择器之和。\n\n优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。 a、b、c、d 权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果 b 的值不同，那么 c 和 d 不管多大，都不会对结果产生影响。比如 0，1，0，0 的优先级高于 0，0，10，10 。\n\n当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。\n\n在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用 !important 的方式，去覆盖组件的样式了。"},{"title":"请阐述 Float 定位的工作原理。","category":"css","ansysis":"参考答案：\n\n浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。\n\nCSS 的 clear 属性通过使用 left 、 right 、 both ，让该元素向下移动（清除浮动）到浮动元素下面。\n\n如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。\n\n有一种 hack 的方法，是自定义一个 .clearfix 类，利用伪元素选择器 ::after 清除浮动。另外还有一些方法，比如添加空的 <div></div> 和设置浮动元素父元素的 overflow 属性。与这些方法不同的是， clearfix 方法，只需要给父元素添加一个类，定义如下：\n\n.clearfix::after {\n    content: \"\";\n    display: block;\n    clear: both;\n}\n值得一提的是，把父元素属性设置为 overflow: auto 或 overflow: hidden ，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。"},{"title":"请阐述 z-index 属性，并说明如何形成层叠上下文（stacking context）","category":"css","ansysis":"参考答案：\n\nCSS 中的 z-index 属性控制重叠元素的垂直叠加顺序。 z-index 只能影响 position 值不是 static 的元素。\n\n没有定义 z-index 的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。\n\n层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的 z-index 值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的 z-index 值，元素 C 也永远不会在元素 B 之上.\n\n每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如 opacity 小于 1， filter 不是 none ， transform 不是 none 。"},{"title":"如何解决不同浏览器的样式兼容性问题？","category":"css","ansysis":"参考答案：\n\n在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。\n使用已经处理好此类问题的库，比如 Bootstrap。\n使用 autoprefixer 自动生成 CSS 属性前缀。\n使用 Reset CSS 或 Normalize. css。\n"},{"title":"如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？","category":"css","ansysis":"参考答案：\n\n优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。\nProgressivepx enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it.\n渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。\n利用 caniuse. com 检查特性支持。\n使用 autoprefixer 自动生成 CSS 属性前缀。\n使用 Modernizr进行特性检测。"},{"title":"对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？","category":"css","ansysis":"参考答案：\n\n喜欢：\n\n绝大部分优点上题以及提过。\nLess 用 JavaScript 实现，与 NodeJS 高度结合。\n不喜欢：\n\n我通过 node-sass 使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。\nLess 中，变量名称以 @ 作为前缀，容易与 CSS 关键字混淆，如 @media 、 @import 和 @font-face 。"},{"title":"解释浏览器如何确定哪些元素与 CSS 选择器匹配。","category":"css","ansysis":"参考答案：\n\n浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。\n\n例如，对于形如 p span 的选择器，浏览器首先找到所有 <span> 元素，并遍历它的父元素直到根元素以找到 <p> 元素。对于特定的 <span> ，只要找到一个 <p> ，就知道'`已经匹配并停止继续匹配。"},{"title":"说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。","category":"css","ansysis":"参考答案：\n\nCSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的 padding 、 border 和 margin 区域。\n\nCSS 盒模型负责计算：\n\n块级元素占用多少空间。\n边框是否重叠，边距是否合并。\n盒子的尺寸。\n盒模型有以下规则：\n\n块级元素的大小由 width 、 height 、 padding 、 border 和 margin 决定。\n如果没有指定 height ，则块级元素的高度等于其包含子元素的内容高度加上 padding （除非有浮动元素，请参阅下文）。\n如果没有指定 width ，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的 padding 。\n元素的 height 是由内容的 height 来计算的。\n元素的 width 是由内容的 width 来计算的。\n默认情况下， padding 和 border 不是元素 width 和 height 的组成部分。"},{"title":"* { box-sizing: border-box; } 会产生怎样的效果？","category":"css","ansysis":"参考答案：\n\n元素默认应用了 box-sizing: content-box ，元素的宽高只会决定内容（content）的大小。\nbox-sizing: border-box 改变计算元素 width 和 height 的方式， border 和 padding 的大小也将计算在内。\n元素的 height = 内容（content）的高度 + 垂直方向的 padding + 垂直方向 border 的宽度\n元素的 width = 内容（content）的宽度 + 水平方向的 padding + 水平方向 border 的宽度"},{"title":"relative 、 fixed 、 absolute 和 static 四种定位有什么区别？","category":"css","ansysis":"参考答案：\n\n经过定位的元素，其 position 属性值必然是 relative 、 absolute 、 fixed 或 static 。\n\nstatic ：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。\nrelative ：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。\nabsolute ：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。\nfixed ：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。\nstatic ：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。 position: static 对 table 元素的效果与 position: relative 相同。"},{"title":"你使用过哪些现有的 CSS 框架？你是如何改进它们的？","category":"css","ansysis":"参考答案：\n\nBootstrap： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。\nSemantic UI：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。\nBulma： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。"},{"title":"你了解 CSS Flex 和 Grid 吗？","category":"css","ansysis":"参考答案：Flex 主要用于一维布局，而 Grid 则用于二维布局。\n\n解析：\n\nFlex\nflex 容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为 flex item。\n\n在容器上可以设置 6 个属性：\n\nflex-direction\nflex-wrap\nflex-flow\njustify-content\nalign-items\nalign-content\n注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。\n\nFlex 项目属性\n有六种属性可运用在 item 项目上:\n\n1. order 2. flex-basis 3. flex-grow 4. flex-shrink 5. flex 6. align-self\n\nGrid\nCSS 网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。\n\n像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用 CSS 网格可能还是比 CSS 表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像 CSS 定位的元素一样，真正的有重叠和层次"},{"title":"响应式设计与自适应设计有何不同？","category":"css","ansysis":"参考答案：\n\n响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。\n\n响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。\n\n自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。"},{"title":"你有没有使用过视网膜分辨率的图形？当中使用什么技术？","category":"css","ansysis":"参考答案：我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像 @media only screen and (min-device-pixel-ratio: 2) { ... } ，然后改变 background-image 。\n\n对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。\n\n还有一种方法是，在检查了 window.devicePixelRatio 的值后，利用 JavaScript 将 <img> 的 src 属性修改，用更高分辨率的版本进行替换。"},{"title":"什么情况下，用 translate() 而不用绝对定位？什么时候，情况相反","category":"css","ansysis":"参考答案： translate() 是 transform 的一个值。改变 transform 或 opacity 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。 transform 使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此 translate() 更高效，可以缩短平滑动画的绘制时间。\n\n当使用 translate() 时，元素仍然占据其原始空间（有点像 position：relative ），这与改变绝对定位不同。"},{"title":"一边固定宽度一边宽度自适应","category":"css","ansysis":"参考答案：可以使用 flex 布局 复制下面的 HTML 和 CSS 代码 用浏览器打开可以看到效果\n\n<div class=\"wrap\">\n    <div class=\"div1\"></div>\n    <div class=\"div2\"></div>\n</div>\n.wrap {\n    display: flex;\n    justify-content: space-between;\n}\n\n.div1 {\n    min-width: 200px;\n}\n\n.div2 {\n    width: 100%;\n    background: #e6e6e6;\n}\n\nhtml,\nbody,\ndiv {\n    height: 100%;\n    margin: 0;\n}"},{"title":"display:none、visibile:hidden、opacity:0 的区别","category":"css","ansysis":"参考答案：\n\n是否隐藏\t是否在文档中占用空间\t是否会触发事件\ndisplay: none\t是\t否\t否\nvisibile: hidden\t是\t是\t否\nopacity: 0\t是\t是\t是"},{"title":"文本超出部分显示省略号","category":"css","ansysis":"参考答案：\n\n单行\noverflow: hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\n多行\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3; // 最多显示几行\noverflow: hidden;"},{"title":"利用伪元素画三角","category":"css","ansysis":"参考答案：\n\n.info-tab {\n    position: relative;\n}\n\n.info-tab::after {\n    content: \"\";\n    border: 4px solid transparent;\n    border-top-color: #2c8ac2;\n    position: absolute;\n    top: 0;\n}"},{"title":"过渡与动画的区别是什么","category":"css","ansysis":"参考答案：\n\ntransition\n\n可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟以一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果而动画属性\n\nanimation\n\n可以制作类似 Flash 动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。"},{"title":"去除 inline-block 元素间间距的方法","category":"css","ansysis":"参考答案：\n\n移除空格\n使用 margin 负值\n使用 font-size:0\nletter-spacing\nword-spacing"},{"title":" 为什么要初始化 CSS 样式","category":"css","ansysis":"参考答案：\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。\n去掉标签的默认样式如：margin, padding，其他浏览器默认解析字体大小，字体设置。"},{"title":"设备像素比","category":"css","ansysis":""},{"title":"::bofore 和 :after 中双冒号和单冒号有什么区别？","category":"css","ansysis":""},{"title":" 有哪些手段可以优化 CSS, 提高性能","category":"css","ansysis":""},{"title":"transform translate transition 的区别","category":"css","ansysis":""},{"title":"全屏滚动的原理是什么？用到了 CSS 的那些属性？","category":"css","ansysis":""},{"title":"你对 line-height 是如何理解的？","category":"css","ansysis":""}],"title":"CSS 面试题","hasAnser":true}
{"_id":"26da8e4962c052f9018fda6c3bb35868","keyWord":"js","js":[{"title":"document load 和 document ready 的区别","category":"js","ansysis":"参考答案：文档解析过程中，ready在加载图片等外部资源前触发，load在之后触发。如果页面中要是没有图片之类的媒体文件的话ready与load是差不多的，但是页面中有文件就不一样了，所以还是推荐大家在工作中用ready\n\n解析：\n\nDOM文档解析：\n\n解析html结构\n加载脚本和样式文件\n解析并执行脚本\n构造html的DOM模型 // ready\n加载图片等外部资源文件\n页面加载完毕 // load\n页面加载完成有两种事件\n\n1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数\n\n缺点：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响\n\n代码形式：\n\n//document load\n$(document).load(function(){\n    ...code...\n})\n2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行\n\n在原生的jS中不包括ready()这个方法，Jquery才有，jquery中有 $().ready(function)。\n\n代码形式为：\n\n//document ready\n$(document).ready(function(){\n    ...code...\n})\n//document ready 简写\n$(function(){\n    ...code...\n})"},{"title":"JavaScript 中如何检测一个变量是一个 String 类型？","category":"js","ansysis":"参考答案：三种方法（typeof、constructor、Object.prototype.toString.call()）\n\n解析：\n\n①\ntypeof\n\ntypeof('123') === \"string\" // true\n\ntypeof '123' === \"string\" // true\n\n②\nconstructor\n\n    '123'.constructor === String // true\n\n③ Object.prototype.toString.call()\n\nObject.prototype.toString.call('123') === '[object String]' // true"},{"title":"请用 js 去除字符串空格？","category":"js","ansysis":"参考答案：replace 正则匹配方法、str.trim()方法、JQ 方法：$.trim(str)方法\n\n解析：\n\n方法一：replace 正则匹配方法\n\n去除字符串内所有的空格：str = str.replace(/\\s*/g, \"\");\n\n去除字符串内两头的空格：str = str.replace(/^\\s*|\\s*$/g, \"\");\n\n去除字符串内左侧的空格：str = str.replace(/^\\s*/, \"\");\n\n去除字符串内右侧的空格：str = str.replace(/(\\s*$)/g, \"\");\n\n示例：\n\nvar str = \" 6 6 \";\nvar str_1 = str.replace(/\\s*/g, \"\");\nconsole.log(str_1); //66\n\nvar str = \" 6 6 \";\nvar str_1 = str.replace(/^\\s*|\\s*$/g, \"\");\nconsole.log(str_1); //6 6//输出左右侧均无空格\n\nvar str = \" 6 6 \";\nvar str_1 = str.replace(/^\\s*/, \"\");\nconsole.log(str_1); //6 6 //输出右侧有空格左侧无空格\n\nvar str = \" 6 6 \";\nvar str_1 = str.replace(/(\\s*$)/g, \"\");\nconsole.log(str_1); // 6 6//输出左侧有空格右侧无空格\n方法二：str.trim()方法\n\ntrim()方法是用来删除字符串两端的空白字符并返回，trim 方法并不影响原来的字符串本身，它返回的是一个新的字符串。\n\n缺陷：只能去除字符串两端的空格，不能去除中间的空格\n\n示例：\n\nvar str = \" 6 6 \";\nvar str_1 = str.trim();\nconsole.log(str_1); //6 6//输出左右侧均无空格\n方法三：JQ 方法：$.trim(str)方法\n\n$.trim() 函数用于去除字符串两端的空白字符。\n\n注意：$.trim()函数会移除字符串开始和末尾处的所有换行符，空格(包括连续的空格)和制表符。如果这些空白字符在字符串中间时，它们将被保留，不会被移除。\n\n示例：\n\nvar str = \" 6 6 \";\nvar str_1 = $.trim(str);\nconsole.log(str_1); //6 6//输出左右侧均无空格"},{"title":"js 是一门怎样的语言，它有什么特点","category":"js","ansysis":"参考答案：\n\n1.脚本语言。JavaScript 是一种解释型的脚本语言, C、C++等语言先编译后执行, 而 JavaScript 是在程序的运行过程中逐行进行解释。\n\n2.基于对象。JavaScript 是一种基于对象的脚本语言, 它不仅可以创建对象, 也能使用现有的对象。\n\n3.简单。JavaScript 语言中采用的是弱类型的变量类型, 对使用的数据类型未做出严格的要求, 是基于 Java 基本语句和控制的脚本语言, 其设计简单紧凑。\n\n4.动态性。JavaScript 是一种采用事件驱动的脚本语言, 它不需要经过 Web 服务器就可以对用户的输入做出响应。\n\n5.跨平台性。JavaScript 脚本语言不依赖于操作系统, 仅需要浏览器的支持。"},{"title":"== 和 === 的不同","category":"js","ansysis":"参考答案： == 是抽象相等运算符，而 === 是严格相等运算符。 == 运算符是在进行必要的类型转换后，再比较。 === 运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回 false 。使用 == 时，可能发生一些特别的事情，例如：\n\n1 == \"1\"; // true\n1 == [1]; // true\n1 == true; // true\n0 == \"\"; // true\n0 == \"0\"; // true\n0 == false; // true\n如果你对 == 和 === 的概念不是特别了解，建议大多数情况下使用 ==="},{"title":"怎样添加、移除、移动、复制、创建和查找节点？","category":"js","ansysis":"参考答案：\n\n1）创建新节点\n\ncreateDocumentFragment() //创建一个 DOM 片段\ncreateElement() //创建一个具体的元素\ncreateTextNode() //创建一个文本节点\n2）添加、移除、替换、插入\n\nappendChild() //添加\nremoveChild() //移除\nreplaceChild() //替换\ninsertBefore() //插入\n3）查找\n\ngetElementsByTagName() //通过标签名称\ngetElementsByName() //通过元素的 Name 属性的值\ngetElementById() //通过元素 Id，唯一性"},{"title":"事件委托是什么","category":"js","ansysis":"参考答案：利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！\n\n解析：\n\n1、那什么样的事件可以用事件委托，什么样的事件不可以用呢？\n\n适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。\n值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。\n不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不用事件委托了。\n2、为什么要用事件委托\n\n1.提高性能\n\n<ul>\n  <li>苹果</li>\n  <li>香蕉</li>\n  <li>凤梨</li>\n</ul>\n\n// good\ndocument.querySelector('ul').onclick = (event) => {\n  let target = event.target\n  if (target.nodeName === 'LI') {\n    console.log(target.innerHTML)\n  }\n}\n\n// bad\ndocument.querySelectorAll('li').forEach((e) => {\n  e.onclick = function() {\n    console.log(this.innerHTML)\n  }\n})\n2.新添加的元素还会有之前的事件。\n3、事件冒泡与事件委托的对比\n\n事件冒泡：box 内部无论是什么元素，点击后都会触发 box 的点击事件\n事件委托：可以对 box 内部的元素进行筛选\n4、事件委托怎么取索引？\n\n    <ul id=\"ul\">\n        <li> aaaaaaaa </li>\n        <li> 事件委托了 点击当前， 如何获取 这个点击的下标 </li>\n        <li> cccccccc </li>\n    </ul>\n    window.onload = function() {\n        var oUl = document.getElementById(\"ul\");\n        var aLi = oUl.getElementsByTagName(\"li\");\n        oUl.onclick = function(ev) {\n            var ev = ev || window.event;\n            var target = ev.target || ev.srcElement;\n            if (target.nodeName.toLowerCase() == \"li\") {\n                var that = target;\n                var index;\n                for (var i = 0; i < aLi.length; i++)\n                    if (aLi[i] === target) index = i;\n                if (index >= 0) alert('我的下标是第' + index + '个');\n                target.style.background = \"red\";\n            }\n        }\n    }\n拓展：\n\n键盘事件：keydown keypress keyup\n鼠标事件：mousedown mouseup mousemove mouseout mouseover"},{"title":"require 与 import 的区别","category":"js","ansysis":"参考答案：两者的加载方式不同、规范不同\n\n第一、两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载\n\nrequire('./a')(); // a 模块是一个函数，立即执行 a 模块函数\n\nvar data = require('./a').data; // a 模块导出的是一个对象\n\nvar a = require('./a')[0]; // a 模块导出的是一个数组 ======> 哪都行\n\nimport $ from 'jquery';\n\nimport * as _ from '_';\n\nimport {a, b, c} from './a';\n\nimport {default as alias, a as a_a, b, c} from './a'; ======>用在开头\n\n第二、规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范\n\n第三、require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。\n\nimport 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。"},{"title":"javascript 对象的几种创建方式","category":"js","ansysis":"参考答案：\n\n第一种：Object 构造函数创建\n\nvar Person = new Object();\nPerson.name = \"Nike\";\nPerson.age = 29;\n这行代码创建了 Object 引用类型的一个新实例，然后把实例保存在变量 Person 中。\n\n第二种：使用对象字面量表示法\n\nvar Person = {}; //相当于 var Person = new Object();\nvar Person = {\n    name: 'Nike';\n    age: 29;\n}\n对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同\n\n在介绍第三种的创建方法之前，我们应该要明白为什么还要用别的方法来创建对象，也就是第一种，第二种方法的缺点所在：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有 100 个对象，那你要输入 100 次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。\n\n第三种：使用工厂模式创建对象\n\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        alert(this.name);\n    };\n    return o;\n}\nvar person1 = createPerson(\"Nike\", 29, \"teacher\");\nvar person2 = createPerson(\"Arvin\", 20, \"student\");\n在使用工厂模式创建对象的时候，我们都可以注意到，在 createPerson 函数中，返回的是一个对象。那么我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。\n\n第四种: 使用构造函数创建对象\n\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function() {\n        alert(this.name);\n    };\n}\nvar person1 = new Person(\"Nike\", 29, \"teacher\");\nvar person2 = new Person(\"Arvin\", 20, \"student\");\n对比工厂模式，我们可以发现以下区别：\n\n1.没有显示地创建对象\n\n2.直接将属性和方法赋给了 this 对象\n\n3.没有 return 语句\n\n4.终于可以识别的对象的类型。对于检测对象类型，我们应该使用 instanceof 操作符，我们来进行自主检测：\n\nalert(person1 instanceof Object); //ture\n\nalert(person1 instanceof Person); //ture\n\nalert(person2 instanceof Object); //ture\n\nalert(person2 instanceof Object); //ture\n同时我们也应该明白，按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。\n\n那么构造函数确实挺好用的，但是它也有它的缺点：\n\n就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法\n\n第五种：原型创建对象模式\n\nfunction Person() {}\nPerson.prototype.name = \"Nike\";\nPerson.prototype.age = 20;\nPerson.prototype.jbo = \"teacher\";\nPerson.prototype.sayName = function() {\n    alert(this.name);\n};\nvar person1 = new Person();\nperson1.sayName();\n使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。\n\n如果是使用原型创建对象模式，请看下面代码：\n\nfunction Person() {}\nPerson.prototype.name = \"Nike\";\nPerson.prototype.age = 20;\nPerson.prototype.jbo = \"teacher\";\nPerson.prototype.sayName = function() {\n    alert(this.name);\n};\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.name = \"Greg\";\nalert(person1.name); //'Greg' --来自实例\nalert(person2.name); //'Nike' --来自原型\n当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。\n\n这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性\n\n第六种：组合使用构造函数模式和原型模式\n\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n}\nPerson.prototype = {\n    constructor: Person,\n    sayName: function() {\n        alert(this.name);\n    };\n}\nvar person1 = new Person('Nike', 20, 'teacher');"},{"title":"JavaScript 继承的方式和优缺点","category":"js","ansysis":"参考答案：六种方式\n\n一、原型链继承\n\n缺点：\n1.引用类型的属性被所有实例共享\n2.在创建 Child 的实例时，不能向 Parent 传参\n二、借用构造函数(经典继承)\n\n优点：\n\n1.避免了引用类型的属性被所有实例共享\n\n2.可以在 Child 中向 Parent 传参\n\n缺点：\n\n1.方法都在构造函数中定义，每次创建实例都会创建一遍方法。\n\n三、组合继承\n\n优点：\n1.融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。\n四、原型式继承\n\n缺点：\n1.包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。\n五、寄生式继承\n\n缺点：\n1.跟借用构造函数模式一样，每次创建对象都会创建一遍方法。\n六、寄生组合式继承\n\n优点：\n1.这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。\n2.与此同时，原型链还能保持不变；\n3.因此，还能够正常使用 instanceof 和 isPrototypeOf。\n开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式"},{"title":"什么是原型链？","category":"js","ansysis":"参考答案：通过一个对象的__proto__可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的__proto__，最后找到了我们的 Object.prototype, 从实例的原型对象开始一直到 Object.prototype 就是我们的原型链"},{"title":"复杂数据类型如何转变为字符串","category":"js","ansysis":"参考答案：\n\n首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值，\n如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法，\n如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，\n如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。\n解析：\n\n// 1;\nvar obj = {\n    valueOf: function() {\n        return 1;\n    }\n};\nconsole.log(obj + \"\"); //'1'\n// 2;\nvar obj = {\n    valueOf: function() {\n        return [1, 2];\n    }\n};\nconsole.log(obj + \"\"); //'[object Object]';\n// 3;\nvar obj = {\n    valueOf: function() {\n        return [1, 2];\n    },\n    toString: function() {\n        return 1;\n    }\n};\nconsole.log(obj + \"\"); //'1';\n// 4;\nvar obj = {\n    valueOf: function() {\n        return [1, 2];\n    },\n    toString: function() {\n        return [1, 2, 3];\n    }\n};\nconsole.log(obj + \"\"); // 报错 Uncaught TypeError: Cannot convert object to primitive value\n拓展：\n\nvar arr = [new Object(), new Date(), new RegExp(), new String(), new Number(), new Boolean(), new Function(), new Array(), Math] console.log(arr.length) // 9\nfor (var i = 0; i < arr.length; i++) {\n    arr[i].valueOf = function() {\n        return [1, 2, 3]\n    }\n    arr[i].toString = function() {\n        return 'toString'\n    }\n    console.log(arr[i] + '')\n}\n1、若 return [1, 2, 3]处为 return \"valueof\"，得到的返回值是 valueof toString 7valueof 说明：其他八种复杂数据类型是先调用 valueOf 方法，时间对象是先调用 toString 方法\n\n2、改成 return [1, 2, 3]，得到的返回值是 9toString 说明：执行 valueof 后都来执行 toString"},{"title":"javascript 的 typeof 返回哪些数据类型","category":"js","ansysis":"参考答案：7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)、\n\n示例：\n\n1、number\n\ntypeof(10);\ntypeof(NaN); // NaN在JavaScript中代表的是特殊非数字值,它本身是一个数字类型。\ntypeof(Infinity)\n2、boolean\n\ntypeof(true);\ntypeof(false);\n3、string\n\ntypeof(\"abc\");\n4、undefined\n\ntypeof(undefined);\ntypeof(a); // 不存在的变量\n5、object\n\n// 对象，数组，null返回object\ntypeof(null);\ntypeof(window);\n6、function\n\ntypeof(Array);\ntypeof(Date);\n7、symbol\n\ntypeof Symbol() // ES6提供的新的类型"},{"title":"一次js请求一般情况下有哪些地方会有缓存处理？","category":"js","ansysis":"参考答案：DNS缓存，CDN缓存，浏览器缓存，服务器缓存。\n\n解析：\n\n1、DNS缓存\nDNS缓存指DNS返回了正确的IP之后，系统就会将这个结果临时储存起来。并且它会为缓存设定一个失效时间 (例如N小时)，在这N小时之内，当你再次访问这个网站时，系统就会直接从你电脑本地的DNS缓存中把结果交还给你，而不必再去询问DNS服务器，变相“加速”了网址的解析。当然，在超过N小时之后，系统会自动再次去询问DNS服务器获得新的结果。 所以，当你修改了 DNS 服务器，并且不希望电脑继续使用之前的DNS缓存时，就需要手动去清除本地的缓存了。\n\n本地DNS迟迟不生效或者本地dns异常等问题，都会导致访问某些网站出现无法访问的情况，这个时候我们就需要手动清除本地dns缓存，而不是等待！\n\n2、CDN缓存\n和Http类似，客户端请求数据时，先从本地缓存查找，如果被请求数据没有过期，拿过来用，如果过期，就向CDN边缘节点发起请求。CDN便会检测被请求的数据是否过期，如果没有过期，就返回数据给客户端，如果过期，CDN再向源站发送请求获取新数据。和买家买货，卖家没货，卖家再进货一个道理^^。\n\nCDN边缘节点缓存机制，一般都遵守http标准协议，通过http响应头中的Cache-Control和max-age的字段来设置CDN边缘节点的数据缓存时间。\n\n3、浏览器缓存\n浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。\n\n浏览器缓存主要有两类：缓存协商：Last-modified ，Etag 和彻底缓存：cache-control，Expires。浏览器都有对应清除缓存的方法。\n\n4、服务器缓存\n服务器缓存有助于优化性能和节省宽带，它将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。"},{"title":"列举 3 种强制类型转换和 2 种隐式类型转换","category":"js","ansysis":"参考答案：\n\n强制: parseInt(), parseFloat(), Number(), Boolean(), String()\n\n隐式: +, -\n\n解析：\n\n// 1.parseInt() 把值转换成整数\nparseInt(\"1234blue\"); // 1234\nparseInt(\"0xA\"); // 10\nparseInt(\"22.5\"); // 22\nparseInt(\"blue\"); // NaN\n// parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：\nparseInt(\"AF\", 16); // 175\nparseInt(\"10\", 2); // 2\nparseInt(\"10\", 8); // 8\nparseInt(\"10\", 10); // 10\n// 如果十进制数包含前导0，那么最好采用基数10，这样才不会意外地得到八进制的值。例如：\nparseInt(\"010\"); // 8\nparseInt(\"010\", 8); // 8\nparseInt(\"010\", 10); // 10\n\n// 2.parseFloat() 把值转换成浮点数,没有基模式\nparseFloat(\"1234blue\"); // 1234.0\nparseFloat(\"0xA\"); // NaN\nparseFloat(\"22.5\"); // 22.5\nparseFloat(\"22.34.5\"); // 22.34\nparseFloat(\"0908\"); // 908\nparseFloat(\"blue\"); // NaN\n\n// 3.Number() 把给定的值转换成数字（可以是整数或浮点数）,Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。示例如下：\nNumber(false) // 0\nNumber(true) // 1\nNumber(undefined) // NaN\nNumber(null) // 0\nNumber(\"5.5\") // 5.5\nNumber(\"56\") // 56\nNumber(\"5.6.7\") // NaN\nNumber(new Object()) // NaN\nNumber(100) // 100\n\n// 4.Boolean() 把给定的值转换成Boolean型\nBoolean(\"\"); // false \nBoolean(\"hi\"); // true\nBoolean(100); // true\nBoolean(null); // false\nBoolean(0); // false\nBoolean(new Object()); // true\n\n// 5.String() 把给定的值转换成字符串\nString(123) // \"123\"\n\n// 6.+ -\nconsole.log(0 + '1') // \"01\"\nconsole.log(2 - '1') // 1"},{"title":"你对闭包的理解？优缺点？","category":"js","ansysis":"参考答案：\n\n概念：闭包就是能够读取其他函数内部变量的函数。\n\n三大特性：\n\n函数嵌套函数。\n函数内部可以引用外部的参数和变量。\n参数和变量不会被垃圾回收机制回收。\n优点：\n\n希望一个变量长期存储在内存中。\n避免全局变量的污染。\n私有成员的存在。\n缺点：\n\n常驻内存，增加内存使用量。\n使用不当会很容易造成内存泄露。\n示例：\n\nfunction outer() {\n    var name = \"jack\";\n\n    function inner() {\n        console.log(name);\n    }\n    return inner;\n}\nouter()(); // jack\nfunction sayHi(name) {\n    return () => {\n        console.log(`Hi! ${name}`);\n    };\n}\nconst test = sayHi(\"xiaoming\");\ntest(); // Hi! xiaoming\n虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。\n但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。\n\n解析：\n\n由于在 ECMA2015 中，只有函数才能分割作用域，函数内部可以访问当前作用域的变量，但是外部无法访问函数内部的变量，所以闭包可以理解成“定义在一个函数内部的函数，外部可以通过内部返回的函数访问内部函数的变量“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。"},{"title":"如何判断 NaN","category":"js","ansysis":"参考答案：isNaN()方法\n\n解析：isNaN(NaN) // true"},{"title":"new 一个对象的过程中发生了什么","category":"js","ansysis":"参考答案：\n\nfunction Person(name) {\n    this.name = name;\n}\nvar person = new Person(\"qilei\");\nnew一个对象的四个过程：\n\n// 1.创建空对象；\nvar obj = {};\n// 2.设置原型链: 设置新对象的 constructor 属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的 prototype 对象；\nobj.constructor = Person;\nobj.__proto__ = Person.prototype;\n// 3.改变this指向：使用新对象调用函数，函数中的 this 指向新实例对象obj：\nvar result = Person.call(obj); //{}.构造函数();\n// 4.返回值：如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接返回该对象。\nif (typeof(result) == \"object\") {\n    person = result;\n} else {\n    person = obj;\n}"},{"title":"for in 和 for of的区别","category":"js","ansysis":"参考答案：\n\n1、for in\n\n1.一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。\n2.不建议使用 for in 遍历数组，因为输出的顺序是不固定的。\n3.如果迭代的对象的变量值是 null 或者 undefined, for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是 null 或者 undefined。\n2、for of\n\n1.for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。\n解析：\n\nvar s = {\n    a: 1,\n    b: 2,\n    c: 3\n};\nvar s1 = Object.create(s);\nfor (var prop in s1) {\n    console.log(prop); //a b c\n    console.log(s1[prop]); //1 2 3\n}\nfor (let prop of s1) {\n    console.log(prop); //报错如下 Uncaught TypeError: s1 is not iterable\n}\nfor (let prop of Object.keys(s1)) {\n    console.log(prop); // a b c\n    console.log(s1[prop]); //1 2 3\n}"},{"title":"如何判断 JS 变量的一个类型（至少三种方式）","category":"js","ansysis":"参考答案：typeof、instanceof、 constructor、 prototype\n\n解析：\n\n1、typeof\n\ntypeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、object、undefined、function等6种数据类型。如果是判断一个基本的类型用typeof就是可以的。\n\ntypeof ''; // string 有效\ntypeof 1; // number 有效\ntypeof true; //boolean 有效\ntypeof undefined; //undefined 有效\ntypeof null; //object 无效\ntypeof []; //object 无效\ntypeof new Function(); // function 有效\ntypeof new Date(); //object 无效\ntypeof new RegExp(); //object 无效\n2、instanceof\n\ninstanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true, 否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，\n\n[] instanceof Array; //true\n{}\ninstanceof Object; //true\nnew Date() instanceof Date; //true\n3、constractor\n\n每一个对象实例都可以通过 constrcutor 对象来访问它的构造函数 。JS 中内置了一些构造函数：Object、Array、Function、Date、RegExp、String等。我们可以通过数据的 constrcutor 是否与其构造函数相等来判断数据的类型。\n\nvar arr = [];\nvar obj = {};\nvar date = new Date();\nvar num = 110;\nvar str = 'Hello';\nvar getName = function() {};\nvar sym = Symbol();\nvar set = new Set();\nvar map = new Map();\n\narr.constructor === Array; // true\nobj.constructor === Object; // true\ndate.constructor === Date; // true\nstr.constructor === String; // true\ngetName.constructor === Function; // true\nsym.constructor === Symbol; // true\nset.constructor === Set; // true\nmap.constructor === Map // true\n4、Object.prototype.toString\n\ntoString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object, xxx], xxx是具体的数据类型，其中包括：String, Number, Boolean, Undefined, Null, Function, Date, Array, RegExp, Error, HTMLDocument, ...基本上所有对象的类型都可以通过这个方法获取到。\n\nObject.prototype.toString.call(''); // [object String]\nObject.prototype.toString.call(1); // [object Number]\nObject.prototype.toString.call(true); // [object Boolean]\nObject.prototype.toString.call(undefined); // [object Undefined]\nObject.prototype.toString.call(null); // [object Null]\nObject.prototype.toString.call(new Function()); // [object Function]\nObject.prototype.toString.call(new Date()); // [object Date]\nObject.prototype.toString.call([]); // [object Array]\nObject.prototype.toString.call(new RegExp()); // [object RegExp]\nObject.prototype.toString.call(new Error()); // [object Error]"},{"title":"for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？","category":"js","ansysis":"参考答案：\n\nfor in 会遍历自身及原型链上的可枚举属性\nObject.keys 会将对象自身的可枚举属性的 key 输出\nObject.getOwnPropertyNames会将自身所有的属性的 key 输出\n解析：\n\nECMAScript 将对象的属性分为两种：数据属性和访问器属性。\n\nvar parent = Object.create(Object.prototype, {\n    a: {\n        value: 123,\n        writable: true,\n        enumerable: true,\n        configurable: true\n    }\n});\n// parent继承自Object.prototype，有一个可枚举的属性a（enumerable:true）。\n\nvar child = Object.create(parent, {\n    b: {\n        value: 2,\n        writable: true,\n        enumerable: true,\n        configurable: true\n    },\n    c: {\n        value: 3,\n        writable: true,\n        enumerable: false,\n        configurable: true\n    }\n});\n//child 继承自 parent ，b可枚举，c不可枚举\nfor in\nfor (var key in child) {\n    console.log(key);\n}\n// b\n// a\n// for in 会遍历自身及原型链上的可枚举属性\n如果只想输出自身的可枚举属性，可使用 hasOwnProperty 进行判断(数组与对象都可以，此处用数组做例子)\n\nlet arr = [1, 2, 3];\nArray.prototype.xxx = 1231235;\nfor (let i in arr) {\n    if (arr.hasOwnProperty(i)) {\n        console.log(arr[i]);\n    }\n}\n// 1\n// 2\n// 3\nObject.keys\nconsole.log(Object.keys(child));\n// [\"b\"]\n// Object.keys 会将对象自身的可枚举属性的key输出\nObject.getOwnPropertyNames\nconsole.log(Object.getOwnPropertyNames(child));\n// [\"b\",\"c\"]\n// 会将自身所有的属性的key输出"},{"title":"iframe 跨域通信和不跨域通信","category":"js","ansysis":"参考答案：\n\n不跨域通信\n主页面\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <title></title>\n</head>\n\n<body>\n    <iframe name=\"myIframe\" id=\"iframe\" class=\"\" src=\"flexible.html\" width=\"500px\" height=\"500px\">\n    </iframe>\n</body>\n<script type=\"text/javascript\" charset=\"utf-8\">\n    function fullscreen() {\n        alert(1111);\n    }\n</script>\n\n</html>\n子页面 flexible.html\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <title></title>\n</head>\n\n<body>\n    我是子页面\n</body>\n<script type=\"text/javascript\" charset=\"utf-8\">\n    // window.parent.fullScreens()\n    function showalert() {\n        alert(222);\n    }\n</script>\n\n</html>\n1、主页面要是想要调取子页面的 showalert 方法\n\nmyIframe.window.showalert();\n2、子页面要掉主页面的 fullscreen 方法\n\nwindow.parent.fullScreens();\n3、js 在 iframe 子页面获取父页面元素:\n\nwindow.parent.document.getElementById(\"元素id\");\n4、js 在父页面获取 iframe 子页面元素代码如下:\n\nwindow.frames[\"iframe_ID\"].document.getElementById(\"元素id\");\n跨域通信\n使用postMessage(官方用法）\n\n子页面\n\nwindow.parent.postMessage(\"hello\", \"http://127.0.0.1:8089\");\n父页面接收\n\nwindow.addEventListener(\"message\", function(event) {\n    alert(123);\n});"},{"title":"H5 与 Native 如何交互","category":"js","ansysis":"参考答案：jsBridge"},{"title":"如何判断一个对象是否为数组","category":"js","ansysis":"参考答案：\n\n第一种方法：使用 instanceof 操作符。\n\n第二种方法：使用 ECMAScript 5 新增的 Array.isArray()方法。\n\n第三种方法：使用使用 Object.prototype 上的原生 toString()方法判断。"},{"title":"<script> 标签的 defer 和 asnyc 属性的作用以及二者的区别？","category":"js","ansysis":"参考答案：\n\n1、defer 和 async 的网络加载过程是一致的，都是异步执行。\n2、区别在于加载完成之后什么时候执行，可以看出 defer 是文档所有元素解析完成之后才执行的。\n3、如果存在多个 defer 脚本，那么它们是按照顺序执行脚本的，而 async，无论声明顺序如何，只要加载完成就立刻执行\n解析：\n\n无论 <script> 标签是嵌入代码还是引用外部文件，只要不包含 defer 属性和 async 属性（这两个属性只对外部文件有效），浏览器会按照 <script> 的出现顺序对他们依次进行解析，也就是说，只有在第一个 <script> 中的代码执行完成之后，浏览器才会执行第二个 <script> 中的代码，并且在解析时，页面的处理会暂时停止。\n\n嵌入代码的解析=执行 外部文件的解析=下载+执行\n\nscript 标签存在两个属性，defer 和 async，这两个属性只对外部文件有效\n\n只有一个脚本的情况\n\n<script src = \"a.js\" />\n没有 defer 或 async 属性，浏览器会立即下载并执行相应的脚本，并且在下载和执行时页面的处理会停止。\n\n\n<script defer src = \"a.js\" />\n有了 defer 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，等到文档解析完成脚本才会执行。\n\n\n<script async src = \"a.js\" />\n有了 async 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，下载完成后立即执行，执行过程中页面处理会停止。\n\n\n<script defer async src = \"a.js\" />\n如果同时指定了两个属性, 则会遵从 async 属性而忽略 defer 属性。\n\n下图可以直观的看出三者之间的区别:\n\njs_002\n\n其中蓝色代表 js 脚本网络下载时间，红色代表 js 脚本执行，绿色代表 html 解析。\n\n多个脚本的情况\n这里只列举两个脚本的情况：\n\n\n<script src = \"a.js\"> </script>\n<script src = \"b.js\"> </script>\n没有 defer 或 async 属性，浏览器会立即下载并执行脚本 a.js，在 a.js 脚本执行完成后才会下载并执行脚本 b.js，在脚本下载和执行时页面的处理会停止。\n\n\n<script defer src = \"a.js\"> </script>\n<script defer src = \"b.js\"> </script>\n有了 defer 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，等到文档解析完成才会执行这两个脚本。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。\n\n\n<script async src = \"a.js\"> </script>\n<script async src = \"b.js\"> </script>\n有了 async 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，a.js 和 b.js 哪个先下载完成哪个就立即执行，执行过程中页面处理会停止，但是其他脚本的下载不会停止。标记为 async 的脚本并不保证按照制定它们的先后顺序执行。异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。"},{"title":"Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏","category":"js","ansysis":"参考答案：\n\nObject.prototype.toString.call()\n优点：这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。\n缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]\ninstanceOf\n优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。\n缺点： instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。\nArray.isArray()\n优点：当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes\n缺点：只能判别数组\n解析：\n\nObject.prototype.toString.call()\n每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。\n\nconst an = [\"Hello\", \"An\"];\nan.toString(); // \"Hello,An\"\nObject.prototype.toString.call(an); // \"[object Array]\"\n这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。\n\nObject.prototype.toString.call(\"An\"); // \"[object String]\"\nObject.prototype.toString.call(1); // \"[object Number]\"\nObject.prototype.toString.call(Symbol(1)); // \"[object Symbol]\"\nObject.prototype.toString.call(null); // \"[object Null]\"\nObject.prototype.toString.call(undefined); // \"[object Undefined]\"\nObject.prototype.toString.call(function() {}); // \"[object Function]\"\nObject.prototype.toString.call({\n    name: \"An\"\n}); // \"[object Object]\"\n缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]\n\nfunction f(name) {\n    this.name = name;\n}\nvar f1 = new f(\"martin\");\nconsole.log(Object.prototype.toString.call(f1)); //[object Object]\n\nObject.prototype.toString.call(); // 常用于判断浏览器内置对象。\ninstanceof\ninstanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n\n使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。\n\n[] instanceof Array; // true\n但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。\n\n[] instanceof Object; // true\n优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。\n\n缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。\n\nfunction f(name) {\n    this.name = name;\n}\nvar f1 = new f(\"martin\");\nconsole.log(f1 instanceof f); //true\nArray.isArray()\n功能：用来判断对象是否为数组\n\ninstanceof 与 isArray\n\n当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes\n\nvar iframe = document.createElement(\"iframe\");\ndocument.body.appendChild(iframe);\nxArray = window.frames[window.frames.length - 1].Array;\nvar arr = new xArray(1, 2, 3); // [1,2,3]\n\n// Correctly checking for Array\nArray.isArray(arr); // true\nObject.prototype.toString.call(arr); // true\n// Considered harmful, because doesn't work though iframes\narr instanceof Array; // false\n缺点：只能判别数组\n\nArray.isArray() 与 Object.prototype.toString.call()\nArray.isArray()是 ES5 新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。\n\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === \"[object Array]\";\n    };\n}"},{"title":"什么是面向对象？","category":"js","ansysis":"参考答案：面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。\n\n解析：\n\n面向对象和面向过程的异同\n面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。\n面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。"},{"title":"JS 严格模式和正常模式","category":"js","ansysis":"参考答案：严格模式使用\"use strict\";\n\n作用：\n\n消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;\n消除代码运行的一些不安全之处，保证代码运行的安全；\n提高编译器效率，增加运行速度；\n为未来新版本的 Javascript 做好铺垫。\n表现：\n\n严格模式下, delete 运算符后跟随非法标识符(即 delete 不存在的标识符)，会抛出语法错误； 非严格模式下，会静默失败并返回 false\n严格模式中，对象直接量中定义同名属性会抛出语法错误； 非严格模式不会报错\n严格模式中，函数形参存在同名的，抛出错误； 非严格模式不会\n严格模式不允许八进制整数直接量（如：023）\n严格模式中，arguments 对象是传入函数内实参列表的静态副本；非严格模式下，arguments 对象里的元素和对应的实参是指向同一个值的引用\n严格模式中 eval 和 arguments 当做关键字，它们不能被赋值和用作变量声明\n严格模式会限制对调用栈的检测能力，访问 arguments.callee.caller 会抛出异常\n严格模式 变量必须先声明，直接给变量赋值，不会隐式创建全局变量，不能用 with,\n严格模式中 call apply 传入 null undefined 保持原样不被转换为 window\n解析：\n\n一、概述\n\n除了正常运行模式，ECMAscript 5 添加了第二种运行模式：\"严格模式\"（strict mode）。顾名思义，这种模式使得 Javascript 在更严格的条件下运行。\n\n设立\"严格模式\"的目的，主要有以下几个：\n\n消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;\n\n消除代码运行的一些不安全之处，保证代码运行的安全；\n\n提高编译器效率，增加运行速度；\n\n为未来新版本的 Javascript 做好铺垫。\n\n\"严格模式\"体现了 Javascript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。\n\n另一方面，同样的代码，在\"严格模式\"中，可能会有不一样的运行结果；一些在\"正常模式\"下可以运行的语句，在\"严格模式\"下将不能运行。掌握这些内容，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。\n\n本文将对\"严格模式\"做详细介绍。\n\n二、进入标志\n\n进入\"严格模式\"的标志，是下面这行语句：\n\n\"use strict\";\n\n老版本的浏览器会把它当作一行普通字符串，加以忽略。\n\n三、如何调用\n\n\"严格模式\"有两种调用方法，适用于不同的场合。\n\n3.1 针对整个脚本文件\n\n将\"use strict\"放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。\n\n(严格地说，只要前面不是产生实际运行结果的语句，\"use strict\"可以不在第一行，比如直接跟在一个空的分号后面。)\n\n\n　　<script>\n　　　　\"use strict\";\n　　　　console.log(\"这是严格模式。\");\n　　</script>\n\n　　<script>\n　　　　console.log(\"这是正常模式。\");kly, it's almost 2 years ago now.I can admit it now - I run it on my school's network that has about 50 computers.\n　　</script>\n上面的代码表示，一个网页中依次有两段 Javascript 代码。前一个 script 标签是严格模式，后一个不是。\n\n3.2 针对单个函数\n\n将\"use strict\"放在函数体的第一行，则整个函数以\"严格模式\"运行。\n\nfunction strict() {\n    \"use strict\";\n    return \"这是严格模式。\";\n}\n\nfunction notStrict() {\n    return \"这是正常模式。\";\n}\n3.3 脚本文件的变通写法\n\n因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n\n(function() {\n    \"use strict\"; // some code here\n\n})();\n四、语法和行为改变\n\n严格模式对 Javascript 的语法和行为，都做了一些改变。\n\n4.1 全局变量显式声明\n\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n\"use strict\";\n\nv = 1; // 报错，v未声明\n\nfor (i = 0; i < 2; i++) {\n    // 报错，i未声明\n}\n因此，严格模式下，变量都必须先用 var 命令声明，然后再使用。\n\n4.2 静态绑定\n\nJavascript 语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。\n\n严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。\n\n具体来说，涉及以下几个方面。\n\n（1）禁止使用 with 语句\n\n因为 with 语句无法在编译时就确定，属性到底归属哪个对象。\n\n\"use strict\";\n\nvar v = 1;\n\nwith(o) { // 语法错误\n    v = 2;\n}\n（2）创设 eval 作用域\n\n正常模式下，Javascript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。\n\n正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。\n\n\"use strict\";\n\nvar x = 2;\n\nconsole.info(eval(\"var x = 5; x\")); // 5\n\nconsole.info(x); // 2\n4.3 增强的安全措施\n\n（1）禁止 this 关键字指向全局对象\n\nfunction f() {\n    return !this;\n} // 返回false，因为\"this\"指向全局对象，\"!this\"就是false\nfunction f() {\n    \"use strict\";\n    return !this;\n} // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n因此，使用构造函数时，如果忘了加 new，this 不再指向全局对象，而是报错。\n\nfunction f() {\n    \"use strict\";\n\n    this.a = 1;\n}\n\nf(); // 报错，this未定义\n（2）禁止在函数内部遍历调用栈\n\nfunction f1() {\n    \"use strict\";\n\n    f1.caller; // 报错\n\n    f1.arguments; // 报错\n}\n\nf1();\n4.4 禁止删除变量\n\n严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除。\n\n\"use strict\";\n\nvar x;\n\ndelete x; // 语法错误\n\nvar o = Object.create(null, {\n    'x': {\n        value: 1,\n        configurable: true\n    }\n});\n\ndelete o.x; // 删除成功\n4.5 显式报错\n\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n\n\"use strict\";\n\nvar o = {};\n\nObject.defineProperty(o, \"v\", {\n    value: 1,\n    writable: false\n});\n\no.v = 2; // 报错\n严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。\n\n\"use strict\";\n\nvar o = {\n    get v() {\n        return 1;\n    }\n};\n\no.v = 2; // 报错\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n\n\"use strict\";\n\nvar o = {};\n\nObject.preventExtensions(o);\n\no.v = 1; // 报错\n严格模式下，删除一个不可删除的属性，会报错。\n\n\"use strict\";\n\ndelete Object.prototype; // 报错\n4.6 重名错误\n\n严格模式新增了一些语法错误。\n\n（1）对象不能有重名的属性\n\n正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n\"use strict\";\n\nvar o = {\n    p: 1,\n    p: 2\n}; // 语法错误\n（2）函数不能有重名的参数\n\n正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。\n\n\"use strict\";\n\nfunction f(a, a, b) { // 语法错误\n\n    return;\n\n}\n4.7 禁止八进制表示法\n\n正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。\n\n\"use strict\";\n\nvar n = 0100; // 语法错误\n4.8 arguments 对象的限制\n\narguments 是函数的参数对象，严格模式对它的使用做了限制。\n\n（1）不允许对 arguments 赋值\n\n\"use strict\";\n\narguments++; // 语法错误\n\nvar obj = {\n    set p(arguments) {}\n}; // 语法错误\n\ntry {} catch (arguments) {} // 语法错误\n\nfunction arguments() {} // 语法错误\n\nvar f = new Function(\"arguments\", \"'use strict'; return 17;\"); // 语法错误\n（2）arguments 不再追踪参数的变化\n\nfunction f(a) {\n    a = 2;\n\n    return [a, arguments[0]];\n}\n\nf(1); // 正常模式为[2,2]\n\nfunction f(a) {\n    \"use strict\";\n\n    a = 2;\n\n    return [a, arguments[0]];\n}\n\nf(1); // 严格模式为[2,1]\n（3）禁止使用 arguments.callee\n\n这意味着，你无法在匿名函数内部调用自身了。\n\n\"use strict\";\n\nvar f = function() {\n    return arguments.callee;\n};\n\nf(); // 报错\n4.9 函数必须声明在顶层\n\n将来 Javascript 的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n\"use strict\";\n\nif (true) {\n    function f() {} // 语法错误\n}\n\nfor (var i = 0; i < 5; i++) {\n    function f2() {} // 语法错误\n}\n4.10 保留字\n\n为了向将来 Javascript 的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n\n使用这些词作为变量名将会报错。\n\nfunction package(protected) { // 语法错误\n\n    \"use strict\";\n\n    var implements; // 语法错误\n\n}\n此外，ECMAscript 第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的 const 保留字，也是不能作为变量名的。"},{"title":"移动端 click 事件、touch 事件、tap 事件的区别","category":"js","ansysis":"参考答案：\n\n1.click 事件在移动端会有 200-300ms 的延迟，主要原因是苹果手机在设计时，考虑到用户在浏览网页时需要放大，所以，在用户点击的 200-300ms 之后，才触发 click，如果 200-300ms 之内还有 click，就会进行放大缩小。\n\n2.touch 事件是针对触屏手机上的触摸事件。现今大多数触屏手机 webkit 内核提供了 touch 事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。其中包括：touchstart, touchmove, touchend, touchcancel 这四个事件，touchstart touchmove touchend 事件可以类比于 mousedown mouseover mouseup 的触发\n\n3.tap 事件在移动端，代替 click 作为点击事件，tap 事件被很多框架（如 zepto）封装，来减少这延迟问题， tap 事件不是原生的，所以是封装的，那么具体是如何实现的呢？\n\n  < script >\n      function tap(ele, callback) {\n          // 记录开始时间\n          var startTime = 0,\n              // 控制允许延迟的时间\n              delayTime = 200,\n              // 记录是否移动，如果移动，则不触发tap事件\n              isMove = false;\n\n          // 在touchstart时记录开始的时间\n          ele.addEventListener('touchstart', function(e) {\n              startTime = Date.now();\n          });\n\n          // 如果touchmove事件被触发，则isMove为true\n          ele.addEventListener('touchmove', function(e) {\n              isMove = true;\n          });\n\n          // 如果touchmove事件触发或者中间时间超过了延迟时间，则返回，否则，调用回调函数。\n          ele.addEventListener('touchend', function(e) {\n              if (isMove || (Date.now() - startTime > delayTime)) {\n                  return;\n              } else {\n                  callback(e);\n              }\n          })\n      }\n\n  var btn = document.getElementById('btn');\n  tap(btn, function() {\n      alert('taped');\n  }); <\n  /script>\n拓展：\n\n点透问题\n\n如果我们在移动端所有的 click 都替换为了 tap 事件，还是会触发点透问题的，因为实质是： 在同一个 z 轴上，z-index 不同的两个元素，上面的元素是一个绑定了 tap 事件的，下面是一个 a 标签，一旦 tap 触发，这个元素就会 display: none，而从上面的 tap 可以看出，有 touchstart、touchend，所以会 300ms 之后触发 click 事件，而 z-index 已经消失了，所以，触发了下面的 a 的 click 事件，注意： 我们认为 a 标签默认是绑定了 click 事件的。而这种现象不是我们所期待的。\n\n解决方案： （1）使用 fastclick。 （2）添加一个延迟。\n\n（1）直接引入 fastclick 库。\n\nwindow.addEventListener(\n    \"load\",\n    function() {\n        FastClick.attach(document.body);\n    },\n    false\n);\n这样，就可以成功解决问题了。\n\n（2）对于上一个 tap 做延迟。\n\ntap(ele, function() {\n    setTimeout(function() {\n        ele.style.display = \"none\";\n    }, 300);\n});\n这样，过了 300ms，那么 click 事件就不会触发在下面的 a 标签上了。"},{"title":"JS 单线程还是多线程，如何显示异步操作","category":"js","ansysis":"参考答案：JS 本身是单线程的，他是依靠浏览器完成的异步操作。\n\n解析：\n\n具体步骤，\n\n1、主线程 执行 js 中所有的代码。\n\n2、主线程 在执行过程中发现了需要异步的任务任务后扔给浏览器（浏览器创建多个线程执行），并在  callback queue  中创建对应的回调函数（回调函数是一个对象，包含该函数是否执行完毕等）。\n\n3、主线程 已经执行完毕所有同步代码。开始监听  callback queue 一旦 浏览器 中某个线程任务完成将会改变回调函数的状态。主线程查看到某个函数的状态为已完成，就会执行该函数。"},{"title":"JavaScript 数组的函数 map/forEach/reduce/filter","category":"js","ansysis":"参考答案：\n\n1.map\n\n// map\n//作用：对数组进行遍历\n//返回值：新的数组\n// 是否改变：否\nvar arr = [2, 5, 3, 4];\nvar ret = arr.map(function(value) {\n    return value + 1;\n});\nconsole.log(ret); //[3,6,4,5]\nconsole.log(arr); //[2,5,3,4]\n2.forEach\n\n// forEach 方法\n// 作用：遍历数组的每一项\n// 返回值：undefined\n// 是否改变：否\nvar arr = [2, 5, 3, 4];\nvar ret = arr.forEach(function(value) {\n    console.log(value); // 2, 5, 3, 4\n});\nconsole.log(ret); //undefined\nconsole.log(arr); //[2,5,3,4]\n3.reduce\n\n// reduce 方法\n// 作用：对数组进行迭代，然后两两进行操作，最后返回一个值\n// 返回值：return出来的结果\n// 是否改变：不会\nvar arr = [1, 2, 3, 4];\nvar ret = arr.reduce(function(a, b) {\n    return a * b;\n});\nconsole.log(ret); // 24\nconsole.log(arr); // [1, 2, 3, 4]\n4.filter\n\n// filter 过滤\n// 作用： 筛选一部分元素\n// 返回值： 一个满足筛选条件的新数组\n// 是否改变原有数组：不会\n\nvar arr = [2, 5, 3, 4];\nvar ret = arr.filter(function(value) {\n    return value > 3;\n});\nconsole.log(ret); //[5,4]\nconsole.log(arr); //[2,5,3,4]"},{"title":"JS 块级作用域、变量提升","category":"js","ansysis":"参考答案：\n\n1.块级作用域\n\nJS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称 ES6)中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。\n\n2.变量提升\n\n如果变量声明在函数里面，则将变量声明提升到函数的开头\n如果变量声明是一个全局变量，则将变量声明提升到全局作用域的开头\n解析：\n\n< script type = \"text/javascript\" > {\n    var a = 1;\n    console.log(a); // 1\n}\nconsole.log(a); // 1\n// 可见，通过var定义的变量可以跨块作用域访问到。\n\n(function A() {\n    var b = 2;\n    console.log(b); // 2\n})();\n// console.log(b); // 报错，\n// 可见，通过var定义的变量不能跨函数作用域访问到\n\nif (true) {\n    var c = 3;\n}\nconsole.log(c); // 3\nfor (var i = 0; i < 4; i++) {\n    var d = 5;\n};\nconsole.log(i); // 4   (循环结束i已经是4，所以此处i为4)\nconsole.log(d); // 5\n// if语句和for语句中用var定义的变量可以在外面访问到，\n// 可见，if语句和for语句属于块作用域，不属于函数作用域。\n\n{\n    var a = 1;\n    let b = 2;\n    const c = 3;\n\n    {\n        console.log(a); // 1\t子作用域可以访问到父作用域的变量\n        console.log(b); // 2\t子作用域可以访问到父作用域的变量\n        console.log(c); // 3\t子作用域可以访问到父作用域的变量\n\n        var aa = 11;\n        let bb = 22;\n        const cc = 33;\n    }\n\n    console.log(aa); // 11\t// 可以跨块访问到子 块作用域 的变量\n    // console.log(bb);\t// 报错\tbb is not defined\n    // console.log(cc);\t// 报错\tcc is not defined\n} <\n/script>\n拓展：\n\nvar、let、const 的区别\n\nvar 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。\nlet 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。\nconst 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。\n同一个变量只能使用一种方式声明，不然会报错\n< script type = \"text/javascript\" >\n    // 块作用域\n    {\n        var a = 1;\n        let b = 2;\n        const c = 3;\n        // c = 4; // 报错\n\n        // let a = 'a';\t// 报错  注：是上面 var a = 1; 那行报错\n        // var b = 'b';\t// 报错：本行报错\n        // const a = 'a1';\t// 报错  注：是上面 var a = 1; 那行报错\n        // let c = 'c';\t// 报错：本行报错\n\n        var aa;\n        let bb;\n        // const cc; // 报错\n        console.log(a); // 1\n        console.log(b); // 2\n        console.log(c); // 3\n        console.log(aa); // undefined\n        console.log(bb); // undefined\n    }\nconsole.log(a); // 1\n// console.log(b); // 报错\n// console.log(c); // 报错\n\n// 函数作用域\n(function A() {\n    var d = 5;\n    let e = 6;\n    const f = 7;\n    console.log(d); // 5\n    console.log(e); // 6  (在同一个{ }中,也属于同一个块，可以正常访问到)\n    console.log(f); // 7  (在同一个{ }中,也属于同一个块，可以正常访问到)\n})();\n// console.log(d); // 报错\n// console.log(e); // 报错\n// console.log(f); // 报错\n<\n/script>"},{"title":"null/undefined 的区别","category":"js","ansysis":"参考答案：\n\nnull： Null 类型，代表“空值\"，代表一个空对象指针，使用 typeof 运算得到 “object\"，所以你可以认为它是一个特殊的对象值。\n\nundefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。"},{"title":"JS 哪些操作会造成内存泄露","category":"js","ansysis":"参考答案：\n\n1）意外的全局变量引起的内存泄露\n\nfunction leak() {\n    leak = \"xxx\"; //leak成为一个全局变量，不会被回收\n}\n2）闭包引起的内存泄露\n\nfunction bindEvent() {\n    var obj = document.createElement(\"XXX\");\n    obj.οnclick = function() {\n        //Even if it's a empty function\n    };\n}\n闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。 解决之道，将事件处理函数定义在外部，解除闭包, 或者在定义事件处理函数的外部函数中，删除对 dom 的引用。\n\n//将事件处理函数定义在外部\nfunction onclickHandler() {\n    //do something\n}\n\nfunction bindEvent() {\n    var obj = document.createElement(\"XXX\");\n    obj.οnclick = onclickHandler;\n}\n\n//在定义事件处理函数的外部函数中，删除对dom的引用\nfunction bindEvent() {\n    var obj = document.createElement(\"XXX\");\n    obj.οnclick = function() {\n        //Even if it's a empty function\n    };\n    obj = null;\n}\n3）没有清理的 DOM 元素引用\n\nvar elements = {\n    button: document.getElementById(\"button\"),\n    image: document.getElementById(\"image\"),\n    text: document.getElementById(\"text\")\n};\n\nfunction doStuff() {\n    image.src = \"http://some.url/image\";\n    button.click():\n        console.log(text.innerHTML)\n}\n\nfunction removeButton() {\n    document.body.removeChild(document.getElementById('button'))\n}\n4）被遗忘的定时器或者回调\n\nvar someResouce = getData();\nsetInterval(function() {\n    var node = document.getElementById(\"Node\");\n    if (node) {\n        node.innerHTML = JSON.stringify(someResouce);\n    }\n}, 1000);\n这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。\n\n5）子元素存在引起的内存泄露\n\n黄色是指直接被 js 变量所引用，在内存里，红色是指间接被 js 变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。\n\n6）IE7/8 引用计数使用循环引用产生的问题\n\nfunction fn() {\n    var a = {};\n    var b = {};\n    a.pro = b;\n    b.pro = a;\n}\nfn();\nfn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn 函数被大量调用，就会造成内存泄漏。在 IE7 与 IE8 上，内存直线上升。 IE 中有一部分对象并不是原生 js 对象。例如，其内存泄漏 DOM 和 BOM 中的对象就是使用 C++以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使 IE 的 js 引擎采用标记清除策略来实现，但 js 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。\n\nvar element = document.getElementById(\"some_element\");\nvar myObject = new Object();\nmyObject.e = element;\nelement.o = myObject;\n上面的例子在一个 DOM 元素（element)与一个原生 js 对象（myObject)之间创建了循环引用。其中，变量 myObject 有一个名为 e 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。\n\n看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做\n\nwindow.οnlοad = function outerFunction() {\n    var obj = document.getElementById(\"element\"):\n        obj.οnclick = function innerFunction() {};\n};\n这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(“element”)，而 document.getElementById(“element”)的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。\n\n最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样\n\nmyObject.element = null;\nelement.o = null;\nwindow.οnlοad = function outerFunction() {\n    var obj = document.getElementById(\"element\"):\n        obj.οnclick = function innerFunction() {};\n    obj = null;\n};\n将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致 Dom 内存泄漏问题，可能是微软做了优化，或者 Dom 的回收方式已经改变\n\n解析：\n\n1、JS 的回收机制\n\nJavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔, 周期性的执行。\n\n到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。\n\n2、标记清除（mark and sweep）\n\njs 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。\n\nfunction test() {\n    var a = 10; //被标记，进入环境\n    var b = 20; //被标记，进入环境\n}\ntest(); //执行完毕之后a、b又被标记离开环境，被回收\n3、引用计数(reference counting)\n\n引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。\n\nfunction test() {\n    var a = {}; //a的引用次数为0\n    var b = a; //a的引用次数加1，为1\n    var c = a; //a的引用次数加1，为2\n    var b = {}; //a的引用次数减1，为1\n}\n4、如何分析内存的使用情况\n\nGoogle Chrome 浏览器提供了非常强大的 JS 调试工具，Memory 视图 profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。 summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。\n\n5、怎样避免内存泄露\n\n1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；\n\n2）注意程序逻辑，避免“死循环”之类的 ；\n\n3）避免创建过多的对象 原则：不用了的东西要及时归还。"},{"title":"重排与重绘的区别，什么情况下会触发？","category":"js","ansysis":"参考答案：\n\n1.简述重排的概念\n\n浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。\n\n2.简述重绘的概念\n\n重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。\n\n3.简述重绘和重排的关系\n\n重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。\n\n4.什么情况下会触发重排？\n\n页面渲染初始化时；（这个无法避免）\n浏览器窗口改变尺寸；\n元素尺寸改变时；\n元素位置改变时；\n元素内容改变时；\n添加或删除可见的 DOM 元素时。\n5.重排优化有如下五种方法\n\n将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。\n如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用）\n将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。\n由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。\n在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。"},{"title":"发布订阅设计模式","category":"js","ansysis":"参考答案：\n\n发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。\n\n解析：\n\n发布订阅模式的构成\n最常见的发布订阅模式就是咱们DOM事件，仔细回想一下我们要给一个按钮，绑定一个事件，当我点击按钮的时候我要让他的颜色变了，并且页面弹出一个弹出框\n\n我们分析一下这个流程：首先，我们得知道给哪个按钮的时候绑定事件，然后我们得知道触发事件以后需要干什么？\n\n那么在这其中谁是发布者？\n\n是DOM中的按钮，因为是在它身上绑定了事件，当我们点击按钮的时候它便向订阅者发布了这个消息\n\n那么谁是订阅者？\n\n是click事件，当点击按钮时，dom发布了一条消息，而事件订阅了它，所以当它被点击的时候，订阅者会接收到消息\n\n简单例子\n上大学的时候甲要打游戏，下午的课不准备去了，然后甲跟乙说，如果下午老师问我去哪了，你就发信息告诉我。然后果然不出所料，下午老师来了，并且问了甲去哪了？然后乙发信息给甲，甲收到信息后干什么乙不知道，乙只是负责如果老师问了就发短信给甲。"},{"title":"jsonp 优缺点？","category":"js","ansysis":"参考答案：\n\njsonp 优缺点\n1.优点\n1.1 它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略；\n1.2 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持\n1.3 在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层终于分 开了。我提供的 jsonp 服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个 jsonp 服务。\n2.缺点\n2.1 它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求\n2.2 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。\n2.3 jsonp 在调用失败的时候不会返回各种 HTTP 状态码。\n2.4 缺点是安全性。万一假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么结果是什么？所有调用这个 jsonp 的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用 jsonp 的时候必须要保证使用的 jsonp 服务必须是安全可信的"},{"title":"兼容各种浏览器版本的事件绑定","category":"js","ansysis":"参考答案：\n\n/*\n兼容低版本IE，ele为需要绑定事件的元素，\neventName为事件名（保持addEventListener语法，去掉on），fun为事件响应函数\n*/\n\nfunction addEvent(ele, eventName, fun) {\n    if (ele.addEventListener) {\n        ele.addEventListener(eventName, fun, false);\n    } else {\n        ele.attachEvent(\"on\" + eventNme, fun);\n    }\n}"},{"title":"typescript 遇到过什么坑","category":"js","ansysis":"参考答案：\n\nmain.ts 报错（ Cannot find module './App.vue'.）\n\n原因： typescript 不能识别.vue 文件\n\n解决办法： 引入 vue 的 typescript declare 库"},{"title":"this 和 apply 的应用","category":"js","ansysis":"参考答案：比如求数组的最大值 Math.max.apply(this, 数组)\n\nvar numbers = [5, 458, 120, -215];\nvar maxInNumbers = Math.max.apply(this, numbers); //第一个参数也可以填Math或null\nconsole.log(maxInNumbers); // 458\nvar maxInNumbers = Math.max.call(this, 5, 458, 120, -215);\nconsole.log(maxInNumbers); // 458"},{"title":"split() join()的区别","category":"js","ansysis":"参考答案：\n\njoin()：用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串\n\nsplit()：用于把一个字符串通过指定的分隔符进行分隔成数组"},{"title":"JavaScript 的数据类型","category":"js","ansysis":"参考答案：JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了 Symbol 类型。其中，Object 是引用类型，其他的都是基本类型(Primitive Type)。"},{"title":"如何判断一个对象是否属于某个类？","category":"js","ansysis":"参考答案：instanceof\n\n解析：\n\nif (a instanceof Person) {\n    alert(\"yes\");\n}"},{"title":"call() 和 apply() 的含义和区别？","category":"js","ansysis":"参考答案：\n\n首先说明两个方法的含义：\n\ncall：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1, args2); 即 A 对象调用 B 对象的方法。\napply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments); 即 A 对象应用 B 对象的方法。\ncall 与 apply 的相同点：\n\n方法的含义是一样的，即方法功能是一样的；\n第一个参数的作用是一样的；\ncall 与 apply 的不同点：两者传入的列表形式不一样\n\ncall 可以传入多个参数；\napply 只能传入两个参数，所以其第二个参数往往是作为数组形式传入\n想一想哪个性能更好一些呢？"},{"title":"sort 排序原理","category":"js","ansysis":"参考答案：冒泡排序法\n\n解析：\n\n冒泡排序法的原理：\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n针对所有的元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n示例：\n\nvar arr = [1, 5, 4, 2];\n// sort()方法的比较逻辑为：\n// 第一轮：1和5比，1和4比，1和2比\n// 第二轮：5和4比，5和2比\n// 第三轮：4和2比\n// 一.sort排序规则 return大于0则交换数组相邻2个元素的位置\n// 二.arr.sort(function (a,b) {})中\n//         a -->代表每一次执行匿名函时候，找到的数组中的当前项；\n//         b -->代表当前项的后一项；\n\n// 1.升序\nvar apple = [45, 42, 10, 147, 7, 65, -74];\n// ①默认法,缺点:只根据首位排序\nconsole.log(apple.sort());\n// ②指定排序规则法,return可返回任何值\nconsole.log(\n    apple.sort(function(a, b) {\n        return a - b; //若return返回值大于0(即a＞b),则a,b交换位置\n    })\n);\n\n//2.降序\nvar arr = [45, 42, 10, 111, 7, 65, -74];\nconsole.log(\n    apple.sort(function(a, b) {\n        return b - a; //若return返回值大于零(即b＞a),则a,b交换位置\n    })\n);"},{"title":"如何判断当前脚本运行在浏览器还是 node 环境中？","category":"js","ansysis":"参考答案：通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中"},{"title":"移动端最小触控区域是多大？","category":"js","ansysis":"参考答案：苹果推荐是 44pt x 44pt"},{"title":"移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？","category":"js","ansysis":"参考答案：\n\n1.300 毫秒 2.因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。 3.推荐 fastclick.js"},{"title":"解释 JavaScript 中的作用域与变量声明提升？","category":"js","ansysis":"参考答案：\n\n我对作用域的理解是只会对某个范围产生作用，而不会对外产生影响的封闭空间。在这样的一些空间里，外部不能访问内部变量，但内部可以访问外部变量。\n所有申明都会被提升到作用域的最顶上\n同一个变量申明只进行一次，并且因此其他申明都会被忽略\n函数声明的优先级优于变量申明，且函数声明会连带定义一起被提升"},{"title":"Node.js 的适用场景？","category":"js","ansysis":"参考答案：比如：RESTFUL API、实时聊天、客户端逻辑强大的单页 APP，具体的例子比如说：本地化的在线音乐应用，本地化的在线搜索应用，本地化的在线 APP 等。"},{"title":"bind、call、apply 的区别","category":"js","ansysis":"参考答案：\n\ncall 和 apply 其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。\ncall 和 apply 都是在调用时生效，改变调用者的 this 指向。\n\n\nlet name = 'Jack'\nconst obj = {name: 'Tom'}\nfunction sayHi() {console.log('Hi! ' + this.name)}\n\nsayHi() // Hi! Jack\nsayHi.call(obj) // Hi! Tom\n\nbind 也是改变 this 指向，不过不是在调用时生效，而是返回一个新函数。\n\n\nconst newFunc = sayHi.bind(obj)\nnewFunc() // Hi! Tom"},{"title":"使用构造函数的注意点","category":"js","ansysis":"参考答案：\n\n1.一般情况下构造函数的首字母需要大写，因为我们在看到一个函数首字母大写的情况，就认定这是一个构造函数，需要跟new关键字进行搭配使用，创建一个新的实例（对象） 2.构造函数在被调用的时候需要跟new关键字搭配使用。 3.在构造函数内部通过this+属性名的形式为实例添加一些属性和方法。 4.构造函数一般不需要返回值，如果有返回值\n\n- 4.1 如果返回值是一个基本数据类型，那么调用构造函数，返回值仍旧是那么创建出来的对象。\n- 4.2 如果返回值是一个复杂数据类型，那么调用构造函数的时候，返回值就是这个return之后的那个复杂数据类型。"},{"title":"如何获取浏览器版本信息","category":"js","ansysis":"参考答案：window.navigator.userAgent"},{"title":"如何实现文件断点续传","category":"js","ansysis":"参考答案：断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。\n\n首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。\n\n因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。\n\n前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。\n\n当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。\n\n只要用 slice 方法就可以了\n\n\nvar packet = file.slice(start, end);\n参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块\n\n如\n\n\nfile.slice(0,1000);\nfile.slice(1000,2000);\nfile.slice(2000,3000);\n// ......\n在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。"},{"title":"数组的常用方法","category":"js","ansysis":"参考答案：\n\n1.Array.map()\n\n此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组\n\nlet arr = [1, 2, 3, 4, 5];\nlet newArr = arr.map(x => x * 2);\n//arr= [1, 2, 3, 4, 5]   原数组保持不变\n//newArr = [2, 4, 6, 8, 10] 返回新数组\n2.Array.forEach()\n\n此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和 map 方法区分\n\nlet arr = [1, 2, 3, 4, 5];\nnum.forEach(x => x * 2);\n// arr = [2, 4, 6, 8, 10]  数组改变,注意和map区分\n3.Array.filter()\n\n此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回\n\nlet arr = [1, 2, 3, 4, 5]\nconst isBigEnough => value => value >= 3\nlet newArr = arr.filter(isBigEnough)\n//newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组\n4.Array.every()\n\n此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回 true，否则为 false：\n\nlet arr = [1, 2, 3, 4, 5]\nconst isLessThan4 => value => value < 4\nconst isLessThan6 => value => value < 6\narr.every(isLessThan4) //false\narr.every(isLessThan6) //true\n5.Array.some()\n\n此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回 true，若所有元素都不满足判断条件，则返回 false：\n\nlet arr = [1, 2, 3, 4, 5]\nconst isLessThan4 => value => value < 4\nconst isLessThan6 => value => value > 6\narr.some(isLessThan4) //true\narr.some(isLessThan6) //false\n6.Array.reduce()\n\n此方法是所有元素调用返回函数，返回值为最后结果, 传入的值必须是函数类型：\n\nlet arr = [1, 2, 3, 4, 5];\nconst add = (a, b) => a + b;\nlet sum = arr.reduce(add);\n//sum = 15  相当于累加的效果\n与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的\n\n7.Array.push()\n\n此方法是在数组的后面添加新加元素，此方法改变了数组的长度：\n\n8.Array.pop()\n\n此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：\n\nlet arr = [1, 2, 3, 4, 5];\narr.pop();\nconsole.log(arr); //[1, 2, 3, 4]\nconsole.log(arr.length); //4\n9.Array.shift()\n\n此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：\n\nlet arr = [1, 2, 3, 4, 5];\narr.shift();\nconsole.log(arr); //[2, 3, 4, 5]\nconsole.log(arr.length); //4\n10.Array.unshift()\n\n此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：\n\nlet arr = [1, 2, 3, 4, 5];\narr.unshift(6, 7);\nconsole.log(arr); //[6, 7, 2, 3, 4, 5]\nconsole.log(arr.length); //7\n11.Array.isArray()\n\n判断一个对象是不是数组，返回的是布尔值\n\n12.Array.concat()\n\n此方法是一个可以将多个数组拼接成一个数组：\n\n`\n\nlet arr1 = [1, 2, 3]\narr2 = [4, 5]\nlet arr = arr1.concat(arr2)\nconsole.log(arr) //[1, 2, 3, 4, 5]\n``\n`　　\n\n13.Array.toString()\n\n 此方法将数组转化为字符串：\n`\n``\njs\nlet arr = [1, 2, 3, 4, 5];\nlet str = arr.toString()\nconsole.log(str) // 1,2,3,4,5\n``\n`　\n\n14.Array.join()\n\n  此方法也是将数组转化为字符串：\n`\n``\njs\nlet arr = [1, 2, 3, 4, 5];\nlet str1 = arr.toString()\nlet str2 = arr.toString(',')\nlet str3 = arr.toString('##')\nconsole.log(str1) // 12345\nconsole.log(str2) // 1,2,3,4,5\nconsole.log(str3) // 1##2##3##4##5\n\n`\n通过例子可以看出和 toString 的区别，可以设置元素之间的间隔~\n\n15.Array.splice(开始位置， 删除的个数，元素)\n\n万能方法，可以实现增删改：\n\nlet arr = [1, 2, 3, 4, 5];\nlet arr1 = arr.splice(2, 0 'haha')\nlet arr2 = arr.splice(2, 3)\nlet arr1 = arr.splice(2, 1 'haha')\nconsole.log(arr1) //[1, 2, 'haha', 3, 4, 5]新增一个元素\nconsole.log(arr2) //[1, 2] 删除三个元素\nconsole.log(arr3) //[1, 2, 'haha', 4, 5] 替换一个元素"},{"title":"字符串常用操作","category":"js","ansysis":"参考答案：\n\ncharAt(index): 返回指定索引处的字符串\ncharCodeAt(index): 返回指定索引处的字符的 Unicode 的值\nconcat(str1, str2, ...): 连接多个字符串，返回连接后的字符串的副本\nfromCharCode(): 将 Unicode 值转换成实际的字符串\nindexOf(str): 返回 str 在父串中第一次出现的位置，若没有则返回-1\nlastIndexOf(str): 返回 str 在父串中最后一次出现的位置，若没有则返回-1\nmatch(regex): 搜索字符串，并返回正则表达式的所有匹配\nreplace(str1, str2):str1 也可以为正则表达式，用 str2 替换 str1\nsearch(regex): 基于正则表达式搜索字符串，并返回第一个匹配的位置\nslice(start, end)：返回字符索引在 start 和 end（不含）之间的子串\nsplit(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量\nsubstr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串\nsubstring(from, to)：返回字符索引在 from 和 to（不含）之间的子串\ntoLowerCase()：将字符串转换为小写\ntoUpperCase()：将字符串转换为大写\nvalueOf()：返回原始字符串值"},{"title":"作用域的概念及作用","category":"js","ansysis":"参考答案：\n\n作用域 ： 起作用的一块区域\n作用域的概念： 对变量起保护作用的一块区域\n作用： 作用域外部无法获取到作用域内部声明的变量，作用域内部能够获取到作用域外界声明的变量。"},{"title":"作用域的分类","category":"js","ansysis":"参考答案：块作用域、词法作用域、动态作用域\n\n解析：\n\n1 块作用域 花括号 {}\n\n2 词法作用域（js 属于词法作用域） 作用域只跟在何处被创建有关系，跟在何处被调用没有关系\n\n3 动态作用域 作用域只跟在何处被调用有关系，跟在何处被创建没有关系"},{"title":"js 属于哪种作用域","category":"js","ansysis":"参考答案：词法作用域（函数作用域）\n\n解析：\n\n// 块作用域\n/*{\n        var num =123;\n    }\n    console.log(num);*/\n// 如果js属于块作用域，那么在花括号外部就无法访问到花括号内部的声明的num变量。\n// 如果js不属于块级作用域，那么花括号外部就能够访问到花括号内部声明的num变量\n// 能够输出num变量，也就说明js不属于块级作用。\n// 在ES6 之前的版本js是不存在块级作用域的。\n\n//js属于词法作用域还是动态作用域\n\n// js中函数可以帮我们去形成一个作用域\n\n/* function fn(){\n        var num =123;\n    }\n    fn();\n    //在函数外界能否访问到num这样一个变量\n    console.log(num)*/ //Uncaught ReferenceError: num is not defined\n// 如果函数能够生成一个作用域，那么在函数外界就无法访问到函数内部声明的变量。\n// js中的函数能够生成一个作用。  函数作用域 。\n\n// 词法作用域：作用的外界只跟作用域在何处创建有关系，跟作用域在何处被调用没有关系\n\nvar num = 123;\n\nfunction f1() {\n    console.log(num); //\n}\n\nfunction f2() {\n    var num = 456;\n    f1(); //f1在f2被调用的时候会被执行 。\n}\nf2();\n\n//如果js是词法作用域，那么就会输出f1被创建的时候外部的num变量 123\n//如果js是动态作用域，那么f1执行的时候就会输出f1被调用时外部环境中的num  456"},{"title":"浮点数精度","category":"js","ansysis":""},{"title":"自执行函数? 用于什么场景？好处?","category":"js","ansysis":"参考答案：\n\n自执行函数: 1、声明一个匿名函数 2、马上调用这个匿名函数。\n作用：创建一个独立的作用域。\n\n好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理\n\n场景：一般用于框架、插件等场景"},{"title":"多个页面之间如何进行通信","category":"js","ansysis":"参考答案：有如下几个方式：\n\ncookie\nweb worker\nlocaleStorage 和 sessionStorage"},{"title":"css 动画和 js 动画的差异","category":"js","ansysis":"参考答案：\n\n1.代码复杂度，js 动画代码相对复杂一些 2.动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css 动画不能添加事件 3.动画性能看，js 动画多了一个 js 解析的过程，性能不如 css 动画好"},{"title":"如何做到修改 url 参数页面不刷新","category":"js","ansysis":"参考答案：\n\nHTML5 引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。\n\nlet stateObj = {\n    foo: \"bar\"\n};\n\nhistory.pushState(stateObj, \"page 2\", \"bar.html\");\n假设当前页面为 foo.html ，执行上述代码后会变为 bar.html ，点击浏览器后退，会变为 foo.html ，但浏览器并不会刷新。 pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL.让我们来解释下这三个参数详细内容：\n\n状态对象 — 状态对象 state 是一个 JavaScript 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态， popstate 事件就会被触发，且该事件的 state 属性包含该历史记录条目状态对象的副本。\n\n状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有 640k 的大小限制。如果你给 pushState() 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage .\n\n标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 state 传递一个短标题。\n\nURL — 该参数定义了新的历史 URL 记录。注意，调用 pushState() 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前 URL 同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前 URL。"},{"title":"数组方法 pop() push() unshift() shift()","category":"js","ansysis":"参考答案：\n\narr.pop() 从后面删除元素，只能是一个，返回值是删除的元素\narr.push() 从后面添加元素，返回值为添加完后的数组的长度\narr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度\narr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素"},{"title":"事件绑定与普通事件有什么区别","category":"js","ansysis":"参考答案：\n\n用普通事件添加相同事件，下面会覆盖上面的，而事件绑定不会\n普通事件是针对非 dom 元素，事件绑定是针对 dom 元素的事件"},{"title":"IE 和 DOM 事件流的区别","category":"js","ansysis":"参考答案：\n\n1.事件流的区别\n\nIE 采用冒泡型事件 Netscape 使用捕获型事件 DOM 使用先捕获后冒泡型事件 示例：\n\n复制代码代码如下:\n\n<body>\n    <div>\n        <button>点击这里</button>\n    </div>\n</body>\n冒泡型事件模型： button->div->body (IE 事件流)\n\n捕获型事件模型： body->div->button (Netscape 事件流)\n\nDOM 事件模型： body->div->button->button->div->body (先捕获后冒泡)\n\n2.事件侦听函数的区别\n\nIE 使用:\n\n[Object].attachEvent(\"name_of_event_handler\", fnHandler); //绑定函数\n[Object].detachEvent(\"name_of_event_handler\", fnHandler); //移除绑定\nDOM 使用：\n\n[Object].addEventListener(\"name_of_event\", fnHandler, bCapture); //绑定函数\n[Object].removeEventListener(\"name_of_event\", fnHandler, bCapture); //移除绑定\nbCapture 参数用于设置事件绑定的阶段，true 为捕获阶段，false 为冒泡阶段。"},{"title":"如何阻止冒泡与默认行为","category":"js","ansysis":"参考答案：\n\n阻止冒泡行为：非 IE 浏览器 stopPropagation()，IE 浏览器 window.event.cancelBubble = true\n阻止默认行为：非 IE 浏览器 preventDefault()，IE 浏览器 window.event.returnValue = false\n解析：\n\n当需要阻止冒泡行为时，可以使用\n\nfunction stopBubble(e) {\n    //如果提供了事件对象，则这是一个非IE浏览器\n    if (e && e.stopPropagation)\n        //因此它支持W3C的stopPropagation()方法\n        e.stopPropagation();\n    //否则，我们需要使用IE的方式来取消事件冒泡\n    else window.event.cancelBubble = true;\n}\n当需要阻止默认行为时，可以使用\n\n//阻止浏览器的默认行为\nfunction stopDefault(e) {\n    //阻止默认浏览器动作(W3C)\n    if (e && e.preventDefault) e.preventDefault();\n    //IE中阻止函数器默认动作的方式\n    else window.event.returnValue = false;\n    return false;\n}"},{"title":"js 中 this 闭包 作用域","category":"js","ansysis":"参考答案：\n\nthis：指向调用上下文\n\n闭包：定义一个函数就开辟了一个局部作用域，整个 js 执行环境有一个全局作用域\n\n作用域：一个函数可以访问其他函数中的变量（闭包是一个受保护的变量空间）"},{"title":"javascript 的本地对象，内置对象和宿主对象","category":"js","ansysis":"参考答案：\n\n1.本地对象\n\nECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象\"。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError\n\n2.内置对象\n\nJS中内置了17个对象，常用的是Array对象、Date对象、正则表达式对象、string对象、Global对象\n\n3.宿主对象\n\n由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM都是宿主对象。"},{"title":"javascript 的同源策略","category":"js","ansysis":"参考答案：一段脚本只能读取来自于同一来源的窗口和文档的属性\n\n解析：\n\n同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自 MDN 官方的解释）\n\n简单来说就是：一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 具体解释：\n\n（1）源包括三个部分：协议、域名、端口（http 协议的默认端口是 80）。如果有任何一个部分不同，则源不同，那就是跨域了。\n\n（2）限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）\n\nCookie、LocalStorage 和 IndexDB 无法获取。\n\n无法获取和操作 DOM。\n\n不能发送 Ajax 请求。我们要注意，Ajax 只适合同源的通信。\n\n同源策略带来的麻烦：ajax 在不同域名下的请求无法实现，需要进行跨域操作"},{"title":"事件冒泡与事件捕获","category":"js","ansysis":"参考答案：\n\n事件冒泡：由最具体的元素（目标元素）向外传播到最不具体的元素\n\n事件捕获：由最不确定的元素到目标元素"},{"title":"foo = foo||bar ，这行代码是什么意思？为什么要这样写？","category":"js","ansysis":"参考答案：\n\n这种写法称为短路表达式\n\n解析：\n\n相当于\n\nvar foo;\nif (foo) {\n    foo = foo;\n} else {\n    foo = bar;\n}\n常用于函数参数的空判断"},{"title":"复杂数据类型如何转变为字符串","category":"js","ansysis":"参考答案：\n\n首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值\n如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法\n如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，\n如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。"},{"title":"javascript 中 this 的指向问题","category":"js","ansysis":"参考答案：\n\n全局环境、普通函数（非严格模式）指向 window\n普通函数（严格模式）指向 undefined\n函数作为对象方法及原型链指向的就是上一级的对象\n构造函数指向构造的对象\nDOM 事件中指向触发事件的元素\n箭头函数...\n解析：\n\n1、全局环境\n全局环境下，this 始终指向全局对象（window），无论是否严格模式；\n\n// 在浏览器中，全局对象为 window 对象：\nconsole.log(this === window); // true\n\nthis.a = 37;\nconsole.log(window.a); // 37\n2、函数上下文调用\n2.1 普通函数\n\n普通函数内部的 this 分两种情况，严格模式和非严格模式。\n\n（1）非严格模式下，没有被上一级的对象所调用, this 默认指向全局对象 window。\n\nfunction f1() {\n    return this;\n}\nf1() === window; // true\n（2）严格模式下，this 指向 undefined。\n\nfunction f2() {\n    \"use strict\"; // 这里是严格模式\n    return this;\n}\nf2() === undefined; // true\n2.2 函数作为对象的方法\n\n（1）函数有被上一级的对象所调用，那么 this 指向的就是上一级的对象。\n\n（2）多层嵌套的对象，内部方法的 this 指向离被调用函数最近的对象（window 也是对象，其内部对象调用方法的 this 指向内部对象， 而非 window）。\n\n//方式1\nvar o = {\n    prop: 37,\n    f: function() {\n        return this.prop;\n    }\n};\n//当 o.f()被调用时，函数内的this将绑定到o对象。\nconsole.log(o.f()); // logs 37\n\n//方式2\nvar o = {\n    prop: 37\n};\n\nfunction independent() {\n    return this.prop;\n}\n//函数f作为o的成员方法调用\no.f = independent;\nconsole.log(o.f()); // logs 37\n\n//方式3\n//this 的绑定只受最靠近的成员引用的影响\no.b = {\n    g: independent,\n    prop: 42\n};\nconsole.log(o.b.g()); // 42\n特殊例子\n\n// 例子1\nvar o = {\n    a: 10,\n    b: {\n        // a:12,\n        fn: function() {\n            console.log(this.a); //undefined\n            console.log(this); //{fn: ƒ}\n        }\n    }\n};\no.b.fn();\n// 例子2\nvar o = {\n    a: 10,\n    b: {\n        a: 12,\n        fn: function() {\n            console.log(this.a); //undefined\n            console.log(this); //window\n        }\n    }\n};\nvar j = o.b.fn;\nj();\n// this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子2中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子1是不一样的，例子1是直接执行了fn\n2.3 原型链中的 this\n\n（1）如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样。\n\nvar o = {\n    f: function() {\n        return this.a + this.b;\n    }\n};\nvar p = Object.create(o);\np.a = 1;\np.b = 4;\n\nconsole.log(p.f()); // 5\n上述例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。当执行 p.f()时，会查找 p 的原型链，找到 f 函数并执行。因为 f 是作为 p 的方法调用的，所以函数中的 this 指向 p。\n\n（2）相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。\n\n（3）call()和 apply()方法：当函数通过 Function 对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的 this 值可绑定到 call() & apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript 内部会尝试将其转换成对象然后指向它。\n\nfunction add(c, d) {\n    return this.a + this.b + c + d;\n}\nvar o = {\n    a: 1,\n    b: 3\n};\n\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n\nfunction tt() {\n    console.log(this);\n}\n// 第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。\ntt.call(5); // 内部转成 Number {[[PrimitiveValue]]: 5}\ntt.call(\"asd\"); // 内部转成 String {0: \"a\", 1: \"s\", 2: \"d\", length: 3, [[PrimitiveValue]]: \"asd\"}\n（4）bind()方法：由 ES5 引入， 在 Function 的原型链上， Function.prototype.bind。通过 bind 方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。\n\nfunction f() {\n    return this.a;\n}\n\nvar g = f.bind({\n    a: \"azerty\"\n});\nconsole.log(g()); // azerty\n\nvar o = {\n    a: 37,\n    f: f,\n    g: g\n};\nconsole.log(o.f(), o.g()); // 37, azerty\n2.4 构造函数中的 this\n\n当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。\n\n构造器返回的默认值是 this 所指的那个对象，也可以手动返回其他的对象。\n\nfunction C() {\n    this.a = 37;\n}\n\nvar o = new C();\nconsole.log(o.a); // 37\n// 为什么this会指向o？首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。\n\nfunction C2() {\n    this.a = 37;\n    return {\n        a: 38\n    }; // 手动设置返回{a:38}对象\n}\n\no = new C2();\nconsole.log(o.a); // 38\n特殊例子\n\n当 this 碰到 return 时\n\n// 例子1\nfunction fn() {\n    this.user = \"追梦子\";\n    return {};\n}\nvar a = new fn();\nconsole.log(a.user); //undefined\n// 例子2\nfunction fn() {\n    this.user = \"追梦子\";\n    return function() {};\n}\nvar a = new fn();\nconsole.log(a.user); //undefined\n// 例子3\nfunction fn() {\n    this.user = \"追梦子\";\n    return 1;\n}\nvar a = new fn();\nconsole.log(a.user); //追梦子\n// 例子4\nfunction fn() {\n    this.user = \"追梦子\";\n    return undefined;\n}\nvar a = new fn();\nconsole.log(a.user); //追梦子\n// 例子5\nfunction fn() {\n    this.user = \"追梦子\";\n    return undefined;\n}\nvar a = new fn();\nconsole.log(a); //fn {user: \"追梦子\"}\n// 例子6\n// 虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊\nfunction fn() {\n    this.user = \"追梦子\";\n    return null;\n}\nvar a = new fn();\nconsole.log(a.user); //追梦子\n\n// 总结：如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。\n2.5 setTimeout & setInterval\n\n（1）对于延时函数内部的回调函数的 this 指向全局对象 window；\n\n（2）可以通过 bind()方法改变内部函数 this 指向。\n\n//默认情况下代码\nfunction Person() {\n    this.age = 0;\n    setTimeout(function() {\n        console.log(this);\n    }, 3000);\n}\n\nvar p = new Person(); //3秒后返回 window 对象\n//通过bind绑定\nfunction Person() {\n    this.age = 0;\n    setTimeout(\n        function() {\n            console.log(this);\n        }.bind(this),\n        3000\n    );\n}\n\nvar p = new Person(); //3秒后返回构造函数新生成的对象 Person{...}\n3、在 DOM 事件中\n3.1 作为一个 DOM 事件处理函数\n\n当函数被用作事件处理函数时，它的 this 指向触发事件的元素（针对 addEventListener 事件）。\n\n// 被调用时，将关联的元素变成蓝色\nfunction bluify(e) {\n    //this指向所点击元素\n    console.log(\"this === e.currentTarget\", this === e.currentTarget); // 总是 true\n    // 当 currentTarget 和 target 是同一个对象时为 true\n    console.log(\"this === e.target\", this === e.target);\n    this.style.backgroundColor = \"#A5D9F3\";\n}\n\n// 获取文档中的所有元素的列表\nvar elements = document.getElementsByTagName(\"*\");\n\n// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色\nfor (var i = 0; i < elements.length; i++) {\n    elements[i].addEventListener(\"click\", bluify, false);\n}\n3.2 作为一个内联事件处理函数\n\n（1）当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素；\n\n（2）当代码被包括在函数内部执行时，其 this 指向等同于 普通函数直接调用的情况，即在非严格模式指向全局对象 window，在严格模式指向 undefined：\n\n<button onclick=\"console.log(this)\">show me</button>\n<button onclick=\"(function () {console.log(this)})()\">show inner this</button>\n<button onclick=\"(function () {'use strict'; console.log(this)})()\">\n    use strict\n</button>\n\n// 控制台打印\n<button onclick=\"console.log(this)\">show me</button>\nWindow {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\nundefined\n4、箭头函数\n4.1 全局环境中\n\n在全局代码中，箭头函数被设置为全局对象：\n\nvar globalObject = this;\nvar foo = () => this;\nconsole.log(foo() === globalObject); // true\n4.2 this 捕获上下文\n\n箭头函数没有自己的 this，而是使用箭头函数所在的作用域的 this，即指向箭头函数定义时（而不是运行时）所在的作用域。\n\n//1、箭头函数在函数内部，以非方法的方法使用\nfunction Person() {\n    this.age = 0;\n    setInterval(() => {\n        this.age++;\n    }, 3000);\n}\nvar p = new Person(); //Person{age: 0}\n\n//普通函数作为内部函数\nfunction Person() {\n    this.age = 0;\n    setInterval(function() {\n        console.log(this);\n        this.age++;\n    }, 3000);\n}\nvar p = new Person(); //Window{...}\n4.2 this 捕获上下文\n\n箭头函数没有自己的 this，而是使用箭头函数所在的作用域的 this，即指向箭头函数定义时（而不是运行时）所在的作用域。\n\n//1、箭头函数在函数内部，以非方法的方法使用\nfunction Person() {\n    this.age = 0;\n    setInterval(() => {\n        console.log(this);\n        this.age++;\n    }, 3000);\n}\nvar p = new Person(); //Person{age: 0}\n\n//普通函数作为内部函数\nfunction Person() {\n    this.age = 0;\n    setInterval(function() {\n        console.log(this);\n        this.age++;\n    }, 3000);\n}\nvar p = new Person(); //Window{...}\n在 setTimeout 中的 this 指向了构造函数新生成的对象，而普通函数指向了全局 window 对象。\n\n4.3 箭头函数作为对象的方法使用\n\n箭头函数作为对象的方法使用，指向全局 window 对象；而普通函数作为对象的方法使用，则指向调用的对象。\n\nvar obj = {\n    i: 10,\n    b: () => console.log(this.i, this),\n    c: function() {\n        console.log(this.i, this);\n    }\n};\nobj.b(); // undefined window{...}\nobj.c(); // 10 Object {...}\n4.4 箭头函数中，call()、apply()、bind()方法无效\n\nvar adder = {\n    base: 1,\n    //对象的方法内部定义箭头函数，this是箭头函数所在的作用域的this，\n    //而方法add的this指向adder对象，所以箭头函数的this也指向adder对象。\n    add: function(a) {\n        var f = v => v + this.base;\n        return f(a);\n    },\n    //普通函数f1的this指向window\n    add1: function() {\n        var f1 = function() {\n            console.log(this);\n        };\n        return f1();\n    },\n    addThruCall: function inFun(a) {\n        var f = v => v + this.base;\n        var b = {\n            base: 2\n        };\n\n        return f.call(b, a);\n    }\n};\n\nconsole.log(adder.add(1)); // 输出 2\nadder.add1(); //输出全局对象 window{...}\nconsole.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder\n4.5 this 指向固定化\n\n箭头函数可以让 this 指向固定化，这种特性很有利于封装回调函数\n\nvar handler = {\n    id: \"123456\",\n\n    init: function() {\n        document.addEventListener(\n            \"click\",\n            event => this.doSomething(event.type),\n            false\n        );\n    },\n\n    doSomething: function(type) {\n        console.log(\"Handling \" + type + \" for \" + this.id);\n    }\n};\n上面代码的 init 方法中，使用了箭头函数，这导致这个箭头函数里面的 this，总是指向 handler 对象。如果不使用箭头函数则指向全局 document 对象。\n\n4.6 箭头函是不适用场景\n\n（1）箭头函数不适合定义对象的方法（方法内有 this），因为此时指向 window；\n\n（2）需要动态 this 的时候，也不应使用箭头函数。\n\n//例1，this指向定义箭头函数所在的作用域，它位于对象cat内，但cat不能构成一个作用域，所以指向全局window，改成普通函数后this指向cat对象。\nconst cat = {\n    lives: 9,\n    jumps: () => {\n        this.lives--;\n    }\n};\n\n//例2，此时this也是指向window，不能动态监听button，改成普通函数后this指向按钮对象。\nvar button = document.getElementById(\"press\");\nbutton.addEventListener(\"click\", () => {\n    this.classList.toggle(\"on\");\n});"}],"title":"JavaScript 面试题","hasAnser":true}
{"_id":"26da8e4962c1a3ea019941664e6535a0","keyWord":"computer","hasAnser":true,"computer":[{"title":"GET和POST的请求的区别","category":"computer","ansysis":"Post 和 Get 是 HTTP 请求的两种方法，其区别如下：\n\n应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。\n发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。\n安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。\n参数类型： post 的参数传递支持更多的数据类型"},{"title":"POST和PUT请求的区别","category":"computer","ansysis":"PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）\nPOST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）"},{"title":"常见的HTTP请求头和响应头","category":"computer","ansysis":"HTTP Request Header 常见的请求头：\n\nAccept:浏览器能够处理的内容类型\nAccept-Charset:浏览器能够显示的字符集\nAccept-Encoding：浏览器能够处理的压缩编码\nAccept-Language：浏览器当前设置的语言\nConnection：浏览器与服务器之间连接的类型\nCookie：当前页面设置的任何Cookie\nHost：发出请求的页面所在的域\nReferer：发出请求的页面的URL\nUser-Agent：浏览器的用户代理字符串\n\nHTTP Responses Header 常见的响应头：\n\nDate：表示消息发送的时间，时间的描述格式由rfc822定义\nserver:服务器名称\nConnection：浏览器与服务器之间连接的类型\nCache-Control：控制HTTP缓存\ncontent-type:表示后面的文档属于什么MIME类型\n\n常见的 Content-Type 属性值有以下四种：\n（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。\n（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。\n（3）application/json：服务器消息主体是序列化后的 JSON 字符串。\n（4）text/xml：该种方式主要用来提交 XML 格式的数据"},{"title":"HTTP状态码304是多好还是少好","category":"computer","ansysis":"服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。\n状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。\n搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。\n产生较多304状态码的原因：\n\n页面更新周期长或不更新\n纯静态页面或强制生成静态html\n\n304状态码出现过多会造成以下问题：\n\n网站快照停止；\n收录减少；\n权重下降"},{"title":"常见的HTTP请求方法","category":"computer","ansysis":"GET: 向服务器获取数据；\nPOST：将实体提交到指定的资源，通常会造成服务器资源的修改；\nPUT：上传文件，更新数据；\nDELETE：删除服务器上的对象；\nHEAD：获取报文首部，与GET相比，不返回报文主体部分；\nOPTIONS：询问支持的请求方法，用来跨域请求；\nCONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；\nTRACE: 回显服务器收到的请求，主要⽤于测试或诊断"},{"title":"OPTIONS请求方法及使用场景","category":"computer","ansysis":"OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。\nOPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。\nOPTIONS请求方法的主要用途有两个：\n\n获取服务器支持的所有HTTP请求方法；\n用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限"},{"title":"HTTP 1.1 和 HTTP 2.0 的区别","category":"computer","ansysis":"二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。\n多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了\"队头堵塞\"【1】的问题。\n数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。\n头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。\n服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。\n\n【1】队头堵塞：\n\n队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。"},{"title":"HTTP和HTTPS协议的区别","category":"computer","ansysis":"HTTP和HTTPS协议的主要区别如下：\n\nHTTPS协议需要CA证书，费用较高；而HTTP协议不需要；\nHTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；\n使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；\nHTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全"},{"title":"GET方法URL长度限制的原因","category":"computer","ansysis":"实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。\nIE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。\nGET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）\n\n下面看一下主流浏览器对get方法中url的长度限制范围：\n\nMicrosoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。\nFirefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。\nSafari (Browser)：URL最大长度限制为 80,000 个字符。\nOpera (Browser)：URL最大长度限制为 190,000 个字符。\nGoogle (chrome)：URL最大长度限制为 8182 个字符。\n\n主流的服务器对get方法中url的长度限制范围：\n\nApache (Server)：能接受最大url长度为8192个字符。\nMicrosoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。\n\n根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作"},{"title":"当在浏览器中输入 Google.com 并且按下回车之后发生了什么？","category":"computer","ansysis":"（1）解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。\n（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。\n（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。\n（4）获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。\n（5）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。\n（6）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。\n（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。\n（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。\n（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。"},{"title":"对keep-alive的理解","category":"computer","ansysis":"HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：\n\nHTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送Connection: keep-alive字段。若想断开keep-alive连接，需发送Connection:close字段；\nHTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection：close首部字段。\n\nKeep-Alive的建立过程：\n\n客户端向服务器在发送请求报文同时在首部添加发送Connection字段\n服务器收到请求并处理 Connection字段\n服务器回送Connection:Keep-Alive字段给客户端\n客户端接收到Connection字段\nKeep-Alive连接建立成功\n\n服务端自动断开过程（也就是没有keep-alive）：\n\n客户端向服务器只是发送内容报文（不包含Connection字段）\n服务器收到请求并处理\n服务器返回客户端请求的资源并关闭连接\n客户端接收资源，发现没有Connection字段，断开连接\n\n客户端请求断开连接过程：\n\n客户端向服务器发送Connection:close字段\n服务器收到请求并处理connection字段\n服务器回送响应资源并断开连接\n客户端接收资源并断开连接\n\n开启Keep-Alive的优点：\n\n较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；\n允许请求和应答的HTTP管线化；\n降低拥塞控制 （TCP连接减少了）；\n减少了后续请求的延迟（⽆需再进⾏握⼿）；\n报告错误⽆需关闭TCP连；\n\n开启Keep-Alive的缺点：\n\n长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源"},{"title":" 页面有多张图片，HTTP是怎样的加载表现？","category":"computer","ansysis":"在HTTP 1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。\n在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求"},{"title":"HTTP请求报文的是什么样的？","category":"computer","ansysis":"请求报⽂有4部分组成:\n\n请求⾏\n请求头部\n空⾏\n请求体\n其中：\n（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。\n（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔\n\nUser-Agent：产⽣请求的浏览器类型。\nAccept：客户端可识别的内容类型列表。\nHost：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。\n\n（3）请求体: post put等请求携带的数据\n"},{"title":"HTTP响应报文的是什么样的？","category":"computer","ansysis":"请求报⽂有4部分组成:\n\n响应⾏\n响应头\n空⾏\n响应体\n响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。\n响应头：响应部⾸组成\n响应体：服务器响应的数据"},{"title":"HTTP协议的优点和缺点","category":"computer","ansysis":"HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。\nHTTP协议具有以下优点：\n\n支持客户端/服务器模式\n简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。\n无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。\n无状态：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。\n灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。\n\nHTTP协议具有以下缺点：\n\n无状态： HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。\n明文传输： 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。\n不安全\n\n（1）通信使用明文（不加密），内容可能会被窃听；\n（2）不验证通信方的身份，因此有可能遭遇伪装；\n（3）无法证明报文的完整性，所以有可能已遭篡改；\n"},{"title":"URL有哪些组成部分","category":"computer","ansysis":"以下面的URL为例：www.aspxfans.com:8080/news/index.…\n从上面的URL可以看出，一个完整的URL包括以下几部分：\n\n协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在\"HTTP\"后面的“//”为分隔符；\n域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用\n端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；\n虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；\n文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；\n锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；\n参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。"},{"title":"与缓存相关的HTTP请求头有哪些","category":"computer","ansysis":"强缓存：\n\nExpires\nCache-Control\n协商缓存：\n\nEtag、If-None-Match\nLast-Modified、If-Modified-Since"},{"title":"什么是HTTPS协议？","category":"computer","ansysis":"超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\nHTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。\n安全层的主要职责就是对发起的HTTP请求的数据进行加密操作 和 对接收到的HTTP的内容进行解密操作。"},{"title":"TLS/SSL的工作原理","category":"computer","ansysis":"TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。\nTLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：\n\n基于散列函数验证信息的完整性\n对称加密算法采用协商的秘钥对数据加密\n非对称加密实现身份认证和秘钥协商\n（1）散列函数hash\n常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。\n特点： 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。\n（2）对称加密\n对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。\n常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。\n特点： 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。\n（3）非对称加密\n非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。\n常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。\n特点： 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。\n综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题"},{"title":"数字证书是什么？","category":"computer","ansysis":"现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。\n首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。\n这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全"},{"title":"HTTPS通信（握手）过程","category":"computer","ansysis":"HTTPS的通信过程如下：\n\n客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。\n服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。\n客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。\n服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。\n客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息"},{"title":"HTTPS的特点","category":"computer","ansysis":"HTTPS的优点如下：\n\n使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；\n使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；\nHTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；\n\nHTTPS的缺点如下：\n\nHTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；\nHTTPS协议握手阶段比较费时，增加页面的加载时间；\nSSL证书是收费的，功能越强大的证书费用越高；\nHTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；\nSSL证书需要绑定IP，不能再同一个IP上绑定多个域名。"},{"title":"HTTPS是如何保证安全的？","category":"computer","ansysis":"先理解两个概念：\n\n对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。\n⾮对称加密：\n\n\n私钥 + 公钥= 密钥对\n即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密\n因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅\n然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密\n\n⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。\n解决⽅案：\n结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。\n此时⼜带来⼀个问题，中间⼈问题：\n如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。\n所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。\n但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。\n数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了"},{"title":"HTTP状态码","category":"computer","ansysis":"状态码的类别：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类别原因描述1xxInformational(信息性状态码)接受的请求正在处理2xxSuccess(成功状态码)请求正常处理完毕3xxRedirection(重定向状态码)需要进行附加操作一完成请求4xxClient Error (客户端错误状态码)服务器无法处理请求5xxServer Error(服务器错误状态码)服务器处理请求出错\n1. 2XX (Success 成功状态码)\n状态码2XX表示请求被正常处理了。\n（1）200 OK\n200 OK表示客户端发来的请求被服务器端正常处理了。\n（2）204 No Content\n该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。\n（3）206 Partial Content\n该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n2. 3XX (Redirection 重定向状态码)\n3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n（1）301 Moved Permanently\n永久重定向。\n该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。\n使用场景：\n\n当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。\n在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n\n（2）302 Found\n临时重定向。\n该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。\n使用场景：\n\n当我们在做活动时，登录到首页自动重定向，进入活动页面。\n未登陆的用户访问用户中心重定向到登录页面。\n访问404页面重新定向到首页。\n\n（3）303 See Other\n该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。\n303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。\n303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。\n注意：\n\n当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。\n301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。\n\n（4）304 Not Modified\n浏览器缓存相关。\n该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。\n带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（if-match、if-none-match、if-modified-since、if-unmodified-since、if-range）中任意首部。\n状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。\n（5）307 Temporary Redirect\n307表示临时重定向。 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。\n307 会遵守浏览器标准，不会从 POST 变成 GET。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。\n3. 4XX (Client Error 客户端错误状态码)\n4XX 的响应结果表明客户端是发生错误的原因所在。\n（1）400 Bad Request\n该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。\n（2）401 Unauthorized\n该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败\n返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n以下情况会出现401：\n\n401.1 - 登录失败。\n401.2 - 服务器配置导致登录失败。\n401.3 - 由于 ACL 对资源的限制而未获得授权。\n401.4 - 筛选器授权失败。\n401.5 - ISAPI/CGI 应用程序授权失败。\n401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。\n\n（3）403 Forbidden\n该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。\nIIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：\n\n403.1 - 执行访问被禁止。\n403.2 - 读访问被禁止。\n403.3 - 写访问被禁止。\n403.4 - 要求 SSL。\n403.5 - 要求 SSL 128。\n403.6 - IP 地址被拒绝。\n403.7 - 要求客户端证书。\n403.8 - 站点访问被拒绝。\n403.9 - 用户数过多。\n403.10 - 配置无效。\n403.11 - 密码更改。\n403.12 - 拒绝访问映射表。\n403.13 - 客户端证书被吊销。\n403.14 - 拒绝目录列表。\n403.15 - 超出客户端访问许可。\n403.16 - 客户端证书不受信任或无效。\n403.17 - 客户端证书已过期或尚未生效\n403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。\n403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。\n403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。\n\n（4）404 Not Found\n该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n以下情况会出现404：\n\n404.0 -（无） – 没有找到文件或目录。\n404.1 - 无法在所请求的端口上访问 Web 站点。\n404.2 - Web 服务扩展锁定策略阻止本请求。\n404.3 - MIME 映射策略阻止本请求。\n\n（5）405 Method Not Allowed\n该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下\nAccess-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE\n\n4. 5XX (Server Error 服务器错误状态码)\n5XX 的响应结果表明服务器本身发生错误.\n（1）500 Internal Server Error\n该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。\n（2）502 Bad Gateway\n该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：\n\n502.1 - CGI （通用网关接口）应用程序超时。\n502.2 - CGI （通用网关接口）应用程序出错。\n\n（3）503 Service Unavailable\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。\n使用场景：\n\n服务器停机维护时，主动用503响应请求；\nnginx 设置限速，超过限速，会返回503。\n\n（4）504 Gateway Timeout\n该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。\n使用场景：代码执行时间超时，或者发生了死循环\n5. 总结\n（1）2XX 成功\n\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n204 No content，表示请求成功，但响应报文不含实体的主体部分\n205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容\n206 Partial Content，进行范围请求\n\n（2）3XX 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求\n\n（3）4XX 客户端错误\n\n400 bad request，请求报文存在语法错误\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n403 forbidden，表示对请求资源的访问被服务器拒绝\n404 not found，表示在服务器上没有找到请求的资源\n\n（4）5XX 服务器错误\n\n500 internal sever error，表示服务器端在执行请求时发生了错误\n501 Not Implemented，表示服务器不支持当前请求所需要的某个功能\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n\n6. 同样是重定向，307，303，302的区别？\n302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get"},{"title":"DNS 协议是什么","category":"computer","ansysis":"概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址"},{"title":"DNS同时使用TCP和UDP协议？","category":"computer","ansysis":"DNS占用53号端口，同时使用TCP和UDP协议。\n（1）在区域传输的时候使用TCP协议\n\n辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。\nTCP是一种可靠连接，保证了数据的准确性。\n\n（2）在域名解析的时候使用UDP协议\n\n客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包"},{"title":"DNS完整的查询过程","category":"computer","ansysis":"DNS服务器解析域名的过程：\n\n首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步\n将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步\n本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址\n本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址\n本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果\n本地DNS服务器将返回结果保存在缓存中，便于下次使用\n本地DNS服务器将返回结果返回给浏览器\n\n比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表"},{"title":"迭代查询与递归查询","category":"computer","ansysis":"实际上，DNS解析是一个包含迭代查询和递归查询的过程。\n\n递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。\n迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。\n\n一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行"},{"title":"DNS 记录和报文","category":"computer","ansysis":"DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为\n（Name，Value，Type，TTL）\n\n其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。\n常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：\n\n如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。\n如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。\n如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。\n如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点"},{"title":"OSI七层模型","category":"computer","ansysis":"1）应用层\nOSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。\n\n在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。\nFTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。\nSMTP是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。\n\n（2）表示层\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。\n（3）会话层\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n（4）传输层\n传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。\n（5）网络层\n本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。\n（6）数据链路层\n将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。\n网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。\n（7）物理层\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。\nOSI七层模型通信特点：对等通信\n对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信"},{"title":"TCP/IP五层协议","category":"computer","ansysis":"应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。\n传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：\n\n传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；\n用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。\n\n\n网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。\n数据链路层 (data link layer)：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。\n物理层 (physical Layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境"},{"title":"TCP 和 UDP的概念及特点","category":"computer","ansysis":"TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：\n（1）UDP\nUDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n它的特点如下：\n1）面向无连接\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n具体来说就是：\n\n在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n2）有单播，多播，广播的功能\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n3）面向报文\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n4）不可靠性\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n5）头部开销小，传输数据报文时是很高效的。\n\nUDP 头部包含了以下几个数据：\n\n两个十六位的端口号，分别为源端口（可选字段）和目标端口\n整个数据报文的长度\n整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误\n\n因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。\n（2）TCP\nTCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。\n它有以下几个特点：\n1）面向连接\n面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n2）仅支持单播传输\n每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n3）面向字节流\nTCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n4）可靠传输\n对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n5）提供拥塞控制\n当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。\n6）提供全双工通信\nTCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）"},{"title":"TCP和UDP的使用场景","category":"computer","ansysis":"TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\nUDP应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）"},{"title":"UDP协议为什么不可靠？","category":"computer","ansysis":"UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：\n\n不保证消息交付：不确认，不重传，无超时\n不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞\n不跟踪连接状态：不必建立连接或重启状态机\n不进行拥塞控制：不内置客户端或网络反馈机制"},{"title":"TCP的重传机制","category":"computer","ansysis":"由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。\nTCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号"},{"title":"TCP的拥塞控制机制","category":"computer","ansysis":"TCP的拥塞控制机制主要是以下四种机制：\n\n慢启动（慢开始）\n拥塞避免\n快速重传\n快速恢复\n\n（1）慢启动（慢开始）\n\n在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）\n思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。\n为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)\n\n当cnwd < ssthresh，使用慢开始算法\n当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法\n当cnwd > ssthresh，使用拥塞避免算法\n\n\n\n（2）拥塞避免\n\n拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。\n思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一\n无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法.\n\n其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。\n\n（3）快速重传\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量\n\n（4）快速恢复\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。"},{"title":"TCP的流量控制机制","category":"computer","ansysis":"一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。\n\n当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。\n当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）\n如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。\n如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。"},{"title":"TCP的可靠传输机制","category":"computer","ansysis":"TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。\nTCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。\n接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。\n发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。\n但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体"},{"title":"TCP的三次握手和四次挥手","category":"computer","ansysis":"1）三次握手\n\n三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\n刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。\n\n第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。\n\n\n首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。\n\n\n第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\n\n\n在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y\n\n\n第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。\n\n\n确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\n\n那为什么要三次握手呢？两次不行吗？\n\n为了确认双方的接收能力和发送能力都正常\n如果是用两次握手，则会出现下面这种情况：\n\n\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n\n简单来说就是以下三步：\n\n第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。\n第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。\n第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。\n\nTCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。\n（2）四次挥手\n\n刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：\n\n第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。\n\n\n即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。\n\n\n第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。\n\n\n即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。\n\n\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\n\n\n即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。\n\n\n第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。\n\n\n即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。\n\n那为什么需要四次挥手呢？\n\n因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。\n\n简单来说就是以下四步：\n\n第一次挥手： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。\n第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。\n第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。\n第四次挥手： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。\n\nTCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭"},{"title":"TCP粘包是怎么回事，如何处理?","category":"computer","ansysis":"默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.\n如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.\n下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:\nA. 先接收到 data1, 然后接收到 data2 .\nB. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.\nC. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.\nD. ⼀次性接收到了 data1 和 data2 的全部数据.\n其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:\n\n多次发送之前间隔⼀个等待时间：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.\n关闭 Nagle 算法：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)\n进⾏封包/拆包： 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包"},{"title":"为什么udp不会粘包？","category":"computer","ansysis":"TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据\nUDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收"},{"title":"对 WebSocket 的理解","category":"computer","ansysis":"WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。\nWebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。\nWebSocket原理：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。\n​\nWebSocket 特点的如下：\n\n支持双向通信，实时性更强\n可以发送文本，也可以发送二进制数据‘’\n建立在TCP协议之上，服务端的实现比较容易\n数据格式比较轻量，性能开销小，通信高效\n没有同源限制，客户端可以与任意服务器通信\n协议标识符是ws（如果加密，则为wss），服务器网址就是 URL\n与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n\nWebsocket的使用方法如下：\n​\n在客户端中：\n// 在index.html中直接写WebSocket，设置服务端的端口号为 9999\nlet ws = new WebSocket('ws://localhost:9999');\n// 在客户端与服务端建立连接后触发\nws.onopen = function() {\n    console.log(\"Connection open.\"); \n    ws.send('hello');\n};\n// 在服务端给客户端发来消息的时候触发\nws.onmessage = function(res) {\n    console.log(res);       // 打印的是MessageEvent对象\n    console.log(res.data);  // 打印的是收到的消息\n};\n// 在客户端与服务端建立关闭后触发\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n}; "},{"title":"即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？","category":"computer","ansysis":"短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。\n短轮询的基本思路： 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。\n长轮询的基本思路： 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。\nSSE 的基本思想： 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。\nWebSocket 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。\n上面的四个通信协议，前三个都是基于HTTP协议的。\n对于这四种即使通信协议，从性能的角度来看：\nWebSocket > 长连接（SEE） > 长轮询 > 短轮询\n但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：\n短轮询 > 长轮询 > 长连接（SEE） > WebSocket\n所以，还是要根据具体的使用场景来判断使用哪种方式"}],"title":"计算机网络面试题"}
