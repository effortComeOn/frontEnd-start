{"_id":"7a79bfab62bd5a3f00db568215e36e9e","basicData":[{"title":"计算机网络","questions":["Internet 如何工作","HTTP 协议","浏览器工作机制","DNS 及其运行机制","了解域名、网站托管"]},{"title":"前端基础","content":[{"title":"HTML","questions":["学习 HTML 基础，标签、元素、表单验证等等","语义化标签","了解 Web 无障碍（Accessibility）","学习 SEO 基础的优化"]},{"title":"CSS","questions":["CSS 基础","制作布局：浮动、定位、显示、盒模型、网格布局、弹性布局","响应式设计和媒体查询（@media）","结合 HTML 制作一个简单的网页作为最佳实践"]},{"title":"JavaScript","questions":["学习语法和基本结构","学习操作 DOM","学习 Fetch API / Ajax（XHR）","ES6+ 和模块化 JavaScript","了解变量提升、事件冒泡机制、作用域、原型、Shadow DOM、严格模式等概念"]}]},{"title":"版本控制","questions":["Git 的基本操作","创建账号并且学习使用 GitHub"]},{"title":"Web 安全知识","questions":["HTTPS","内容安全策略（CSP）","跨域资源共享","OWASP 安全风险"]}],"engineerData":[{"title":"包管理工具","questions":["npm","yarn","nvm"]},{"title":"CSS 预处理器","questions":["SASS","Less","PostCss"]},{"title":"构建工具","content":[{"title":"任务执行器","questions":["npm scripts"]},{"title":"代码检查和格式化工具","questions":["Prettier 代码格式化","ESLint 代码检查"]},{"title":"模块打包","questions":["webpack","rollup","Vite"]}]}],"frontEndFrame":[{"title":"前端框架","questions":["Solid","Svelte"],"content":[{"title":"React.js","questions":["Redux （状态管理）","MobX"]},{"title":"Vue.js","questions":["VueX （状态管理）"]},{"title":"Vue.js","questions":["VueX （状态管理）"]},{"title":"Angular","questions":["RxJS","NgRx"]}]}],"unitTest":[{"title":"单元测试","questions":["Jest","react-testing-library"]}],"typeScript":[{"title":"类型检查器","questions":["TypeScript"]}],"serverRendar":[{"title":"服务端渲染","questions":["Next.js (React.js)","Nuxt.js (Vue.js)","Universal（Angular）"]}],"mobileApp":[{"title":"移动端应用开发","questions":["ReactNative","Flutter"]}],"title":"前端学习框架","keyWord":"frameWork"}
{"_id":"7a79bfab62c00a2c01028826366b032d","html":[{"ansysis":"参考答案：\n\n①用正确的标签做正确的事情。\n\n②html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\n\n③ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;\n\n④ 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。","category":"html","title":"简述一下你对 HTML 语义化的理解？"},{"title":"Label 的作用是什么？是怎么用的？","ansysis":"参考答案：label 标签来定义表单控制间的关系, 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。","category":"html"},{"ansysis":"参考答案：\n\n优点：\niframe 能够原封不动的把嵌入的网页展现出来。\n如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。\n网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。\n如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。\n缺点：\n框架结构中出现各种滚动条\niframe 会阻塞主页面的 Onload 事件\n搜索引擎的检索程序无法解读这种页面，不利于 SEO\niframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。","category":"html","title":"iframe 框架有哪些优缺点？"},{"ansysis":"应该使用XHTML，因为XHTML是XML重写了HTML的规范，比HTML更加严格，表现如下：\n\n1、XHTML中所有的标记都必须有一个相应的结束标签；\n\n2、XHTML所有标签的元素和属性的名字都必须使用小写；\n\n3、所有的XML标记都必须合理嵌套；\n\n4、所有的属性都必须用引号“”括起来；\n\n5、把所有<和&特殊符号用编码表示；\n\n6、给所有属性附一个值；\n\n7、不要在注释内容中使用“--”；\n\n8、图片必须使用说明文字。","category":"html","title":"HTML 与 XHTML 二者有什么区别，你觉得应该使用哪一个并说出理由。"},{"ansysis":"参考答案：将不想要自动完成的 form 或 input 设置为 autocomplete=off\n\n","category":"html","title":"HTML5 的 form 如何关闭自动完成功能？"},{"category":"html","title":"title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？","ansysis":"\n①title用于网站信息标题，突出网站标题或关键字，一个网站可以有多个title，seo权重高于H1；H1概括的是文章主题，一个页面最好只用一个H1，seo权重低于title。\n\n解析：\n\nA.从网站角度而言，title则重于网站信息标题，突出网站标题或关键字用title，一篇文章，一个页面最好只\n\n用一个H1，H1用得太多，会稀释主题；一个网站可以有多个title，最好一个单页用一个title以便突出网站页面\n\n主题信息。\n\nB.从文章角度而言，H1则概括的是文章主题，突出文章主题，用H1，面对的用户，要突出其视觉效果。\n\nC.从SEO角度而言，title的权重高于H1，其适用性要比H1广。\n\n②b为了加粗而加粗，strong为了标明重点而加粗\n\n解析：\n\nA.b这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；\n\nB.strong这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；\n\n③ 同②i为了斜体而斜体，em为了标明重点而斜体，且对于搜索引擎来说strong和em比b和i要重视的多"},{"ansysis":"参考答案：在 SEO 中，所谓的 TDK 其实就是 title、description、keywords 这三个标签，title 标题标签，description 描述标签，keywords 关键词标签","category":"html","title":"请描述下 SEO 中的 TDK？"},{"ansysis":"参考答案： <! DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。\n\n告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n\n告诉浏览器按照何种规范解析页（如果你的页面没有 DOCTYPE 的声明，那么 compatMode 默认就是 BackCompat, 浏览器按照自己的方式解析渲染页面）\n\n解析：\n\ndoctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。\n\n<! DOCTYPE>声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。\n\n<! DOCTYPE>声明必须是HTML文档的第一行，位于html标签之前。\n\n浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 doctype 来区分这两种模式，doctype 在 html 中的作用就是触发浏览器的标准模式，如果 html 中省略了 doctype，浏览器就会进入到 Quirks 模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而 html 标准和 dom 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 html 开头使用 doctype。","category":"html","title":"每个 HTML 文件头里都有个很重要的东西，Doctype，知道这是干什么的么？"},{"ansysis":"参考答案：src 用于引用资源，替换当前元素；href 用于在当前文档和引用资源之间确立联系。\n\n解析：\n\nhref\nhref 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，是在当前元素和引用资源之间建立联系\n若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。\nsrc\nsrc 表示引用资源，替换当前元素，用在 img，script，iframe 上，src 是页面内容不可缺少的一部分。\n当浏览器解析到 src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。","category":"html","title":"简述一下 src 与 href 的区别。"},{"ansysis":"参考答案：\n\n严格模式：以浏览器支持的最高标准运行\n\n混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为","category":"html","title":"严格模式与混杂模式"},{"ansysis":"参考答案：\n\nweb 标准简单来说可以分为结构、表现和行为。其中结构主要是有 HTML 标签组成。或许通俗点说，在页面 body 里面我们写入的标签都是为了页面的结构。表现即指 css 样式表，通过 css 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 js 组成。\n\nweb 标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。\n\nW3C 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点\n\n对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）\n1）标签字母要小写\n\n2）标签要闭合\n\n3）标签不允许随意嵌套\n\n对于 css 和 js 来说\n1）尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。\n\n2）样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版\n\n3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。","category":"html","title":"对于 WEB 标准以及 W3C 的理解与认识问题"},{"ansysis":"参考答案：\n\na. IE 的排版引擎是 Trident （又称为 MSHTML）\n\nb. Trident 内核曾经几乎与 W3C 标准脱节（2005 年）\n\nc. Trident 内核的大量 Bug 等安全性问题没有得到及时解决\n\nd. JS 方面，有很多独立的方法，例如绑定事件的 attachEvent、创建事件的 createEventObject 等\n\ne. CSS 方面，也有自己独有的处理方式，例如设置透明，低版本 IE 中使用滤镜的方式","category":"html","title":"列举 IE 与其他浏览器不一样的特性"},{"category":"html","title":"前端页面有哪三层构成，分别是什么？作用是什么？","ansysis":"参考答案：分成：结构层、表示层、行为层。\n\n结构层（structural layer）\n由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”\n\n表示层（presentation layer）\n由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。\n\n行为层（behaviorlayer）\n负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。"},{"ansysis":"参考答案：\n\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试","category":"html","title":"网页验证码是干嘛的，是为了解决什么安全问题？"},{"title":"为什么用多个域名存储网站资源更有效？","ansysis":"参考答案：\n\n1、CDN 缓存更方便\n\n2、突破浏览器并发限制\n\n3、节约 cookie 带宽\n\n4、节约主域名的连接数，优化页面响应速度\n\n5、防止不必要的安全问题","category":"html"},{"ansysis":"参考答案：\n\n页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是.........，(把浏览器最小化，所有的页面就都不可见了)。\n\nAPI 很简单，document.hidden 就返回一个布尔值，如果是 true, 表示页面可见，false 则表示，页面隐藏。 不同页面之间来回切换，触发 visibilitychange 事件。 还有一个 document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。\n\ndocument.addEventListener(\"visibilitychange\", function() {\n    if (document.hidden) {\n        document.title = \"hidden\";\n    } else {\n        document.title = \"visibile\";\n    }\n});\n我们打开这个页面，然后再打开另一个页面，来回点击这两个页面，当我们看到这个页面时，标题显示 visiable , 当我们看另一个页面时，标题显示 hidden;","category":"html","title":"页面可见性（Page Visibility）API 可以有哪些用途？"},{"category":"html","title":"Quirks(怪癖）模式是什么？它和 Standards（标准）模式有什么区别","ansysis":"参考答案：\n\n1 以 ie6 为例，如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。\n\n2 区别：总体会有布局、样式解析和脚本执行三个方面的区别。\n\n设置一个元素的宽度和高度\n\n给 <span> 等行内元素设置 width 和 height\n\n用 margin:0 auto 设置水平居中\n\n从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。\n\n在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果 IE6  支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？\n\n在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数   不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定   如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。\n\n区别：\n\n总体会有布局、样式解析和脚本执行三个方面的区别。\n\n盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks  模式下，IE 的宽度和高度还包含了 padding 和 border。\n\n设置行内元素的高宽：在 Standards 模式下，给 <span> 等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。\n\n设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的\n\n用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。\n\n（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）"},{"title":"div+css 的布局较 table 布局有什么优点？","ansysis":"参考答案：分离 方便改版 快清晰简洁 seo\n\n改版的时候更方便 只要改 css 文件。\n\n页面加载速度更快、结构化清晰、页面显示简洁。\n\n表现与结构相分离。\n\n易于优化（seo）搜索引擎更友好，排名更容易靠前。","category":"html"},{"ansysis":"参考答案：\n\n渐进增强  progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n（一开始保证最基本的功能，再改进和追加功能）\n\n优雅降级  graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n（一开始就构建完整的功能，再针对低版本浏览器进行兼容。）\n\n区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。","category":"html","title":"你能描述一下渐进增强和优雅降级之间的不同吗?"},{"title":"请谈一下你对网页标准和标准制定机构重要性的理解。","ansysis":"参考答案：降低开发难度及开发成本，减少各种 BUG、安全问题， 提高网站易用性","category":"html"},{"title":"html 常见兼容性问题？","ansysis":"参考答案：\n\n双边距 BUG float 引起的，解决办法: 使用 display解决\n2.3 像素问题 使用 float 引起的，解决办法: 使用 dislpay:inline -3px\n\n超链接 hover 点击后失效，解决办法: 使用正确的书写顺序 link visited hover active\n\nIe z-index 问题，解决办法: 给父级添加 position:relative\n\nPng 透明 ，解决办法: 使用 js 代码\n\nMin-height 最小高度 ，解决办法: ！Important 解决\n\n7.select 在 ie6 下遮盖，解决办法: 使用 iframe 嵌套\n\n为什么没有办法定义 1px 左右的宽度容器，解决办法: （IE6 默认的行高造成的，使用 over:hidden, zoom:0.08 line-height:1px）\n\nIE5-8 不支持 opacity，解决办法：\n\n.opacity {\n    opacity: 0.4;\n    filter: alpha(opacity=60);/_ for IE5-7 _/ -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=60)\";/_ for IE 8_/\n}\nIE6 不支持 PNG 透明背景，解决办法: IE6 下使用 gif 图片","category":"html"},{"category":"html","title":"对 WEB 标准以及 W3C 的理解与认识","ansysis":"参考答案：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。"},{"title":"如何在页面上实现一个圆形的可点击区域？","ansysis":"参考答案：css3、js、map 加 area\n\n一.border-radius (css3)\n\n对于圆形，最直接的方法想到的就是 css3 的圆角属性，这个属性可以将 html 元素的形状设置为圆形，这之后你想对该圆形区域设置什么事件就设置什么事件(当然包括点击)。（这里就不做具体的 test 了）\n\n二. 通过事件坐标来实现（js）\n\n也就是通过 js 来进行一个区域判断，进而简介地的形成可点区域","category":"html"},{"ansysis":"参考答案：\n\n合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可\n\n语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页\n\n重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n\n重要内容不要用 js 输出：爬虫不会执行 js 获取内容\n\n少用 iframe：搜索引擎不会抓取 iframe 中的内容\n\n非装饰性图片必须加 alt\n\n提高网站速度：网站速度是搜索引擎排序的一个重要指标","category":"html","title":"前端需要注意哪些 SEO"},{"ansysis":"参考答案：\n\n新特性：\n\n拖拽释放(Drag and drop) API\n\n语义化更好的内容标签（header,nav,footer,aside,article,section）\n\n音频、视频 API(audio,video)\n\n画布(Canvas) API\n\n地理(Geolocation) API\n\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n\nsessionStorage 的数据在浏览器关闭后自动删除\n\n表单控件，calendar、date、time、email、url、search\n\n新的技术 webworker, websocket, Geolocation\n\n移除的元素：\n\n纯表现的元素：basefont，big，center，font, s，strike，tt，u；\n\n对可用性产生负面影响的元素：frame，frameset，noframes；\n\n支持 HTML5 新标签：\n\nIE8/IE7/IE6 支持通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签， 浏览器支持新标签后，还需要添加标签默认的样式：\n当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架","category":"html","title":"html5 有哪些新特性、移除了那些元素？"},{"ansysis":"参考答案：\n\n在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\n原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。","category":"html","title":"HTML5 的离线储存怎么使用，工作原理能不能解释一下？"},{"ansysis":"参考答案：在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。","category":"html","title":"浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢"},{"ansysis":"参考答案：\n\naccesskey: 设置快捷键，提供快速访问元素如aaa在 windows 下的 firefox 中按 alt + shift + a 可激活元素\nclass: 为元素设置类标识，多个类名用空格分开，CSS 和 javascript 可通过 class 属性获取元素\ncontenteditable: 指定元素内容是否可编辑\ncontextmenu: 自定义鼠标右键弹出菜单内容\ndata-*: 为元素增加自定义属性\ndir: 设置元素文本方向\ndraggable: 设置元素是否可拖拽\ndropzone: 设置元素拖放类型： copy, move, link\nhidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果\nid: 元素 id，文档内唯一\nlang: 元素内容的的语言\nspellcheck: 是否启动拼写和语法检查\nstyle: 行内 css 样式\ntabindex: 设置元素可以获得焦点，通过 tab 可以导航\ntitle: 元素相关的建议信息\ntranslate: 元素和子孙节点内容是否需要本地化","category":"html","title":"HTML 全局属性(global attribute)有哪些"},{"ansysis":"参考答案：Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。\n\nCanvas 通过 Javascript 来绘制 2D 图形。 是逐像素进行渲染的。 其位置发生改变，会重新进行绘制。\nSVG 是一种使用 XML 描述的 2D 图形的语言 SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\nCanvas\n\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以 .png 或 .jpg 格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\nSVG\n\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n不适合游戏应用","category":"html","title":"Canvas 和 SVG 有什么区别？"},{"ansysis":"参考答案：HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML 是标准通用标记语言, 简单的说，就是比 HTML, XML 更老的标准，这两者都是由 SGML 发展而来的。BUT，HTML5 不是的。\n\n<! DOCTYPE> 声明位于位于 HTML 文档中的第一行，处于 <html> 标签之前。作用：告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以怪异模式呈现","category":"html","title":"HTML5 为什么只需要写 <! DOCTYPE HTML> ？"},{"ansysis":"参考答案：\n\nmeta viewport 标签的作用是让当前 viewport 的宽度等于设备的宽度，同时不允许用户进行手动缩放\n\nviewport的原理：移动端浏览器通常都会在一个比移动端屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是 viewport; 目的是正常展示没有做移动端适配的网页，让他们完整的展示给用户；\n\n解析：\n\nViewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。\n\n在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。 举个例子：如果我们的屏幕是 320 像素 * 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。\n\n为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。\n\nViewport 属性值\nwidth 设置 layout viewport 的宽度，为一个正整数，或字符串\"width-device\"\ninitial-scale 设置页面的初始缩放值，为一个数字，可以带小数\nminimum-scale 允许用户的最小缩放值，为一个数字，可以带小数\nmaximum-scale 允许用户的最大缩放值，为一个数字，可以带小数\nheight 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用\nuser-scalable 是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。\n","category":"html","title":"meta viewport 原理是什么？"},{"ansysis":"参考答案：\n\n可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力。\n\n可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性\n\n可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。","category":"html","title":"对 web 标准、可用性、可访问性的理解"},{"category":"html","title":"HTML5 引入什么新的表单属性？","ansysis":"参考答案：Datalist datetime output keygen date month week time number range emailurl\n\n"},{"ansysis":"HTML5文档类型：<!doctype html>\nHTML5使用的编码<meta charset=”UTF-8”>","category":"html","title":"新的 HTML5 文档类型和字符集是？"},{"ansysis":"参考答案：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。\n\n","category":"html","title":"HTML5 Canvas 元素有什么用？"},{"category":"html","title":"HTML5 存储类型有什么区别？","ansysis":"参考答案：Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API"},{"category":"html","title":"iframe 的作用","ansysis":"参考答案：iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载。\n\n优点\n\n便于修改，模拟分离，像一些信息管理系统会用到。\n但现在基本不推荐使用。除非特殊需要，一般不推荐使用。\n缺点\n\niframe 的创建比一般的 DOM 元素慢了 1-2 个数量级\niframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。\niframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。\n"},{"title":"为什么最好把 CSS 的 <link> 标签放在 <head></head> 之间？为什么最好把 JS 的 <script> 标签恰好放在 </body> 之前，有例外情况吗？","ansysis":"参考答案：\n\n把 <link> 放在 <head> 中\n\n把 <link> 标签放在 <head></head> 之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。\n\n把 <script> 标签恰好放在 </body> 之前\n\n脚本在下载和执行期间会阻止 HTML 解析。把 <script> 标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。\n\n例外情况是当你的脚本里包含 document.write() 时。但是现在， document.write() 不推荐使用。同时，将 <script> 标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是， <script> 使用 defer 属性，放在 <head> 中。","category":"html"},{"ansysis":"参考答案：\n\nDOM\nDocument Object Model，文档对象模型\n\nDOM 是为了操作文档出现的 API，document 是其的一个对象\n\nDOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容。\n\nBOM\nBrowser Object Model，浏览器对象模型\n\nBOM 是为了操作浏览器出现的 API，window 是其的一个对象\n\nwindow 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象","category":"html","title":"DOM 和 BOM 有什么区别"},{"ansysis":"参考答案：title 指图片的信息、alt 指图片不显示时显示的文字","category":"html","title":"img 上 title 与 alt"},{"ansysis":"参考答案：\n\ncss的方案\nonresize\n监听鼠标动作，鼠标释放后重新定宽","category":"html","title":"一个iframe，内嵌了一个A页面，iframe的宽高不停变化，如何让A页面的宽高实时自适应这个iframe的宽高大小。请说出至少3种方法，越难越好"},{"ansysis":"参考答案：\n\nHTML 解释器\nHTML 解释器的工作就是将网络或者本地磁盘获取的 HTML 网页和资源从字节流解释成 DOM 树结构。\n\nJavaScript 的执行\n在 HTML 解释器的工作过程中，可能会有 JavaScript 代码需要执行，它发生在将字符串解释成词语之后、创建各种节点的时候。这也是为什么全局执行的 JavaScript 代码不能访问 DOM 的原因——因为 DOM 树还没有被创建完呢。","category":"html","title":"DOM Tree是如何构建的？"},{"ansysis":"参考答案：noscript 元素用来定义在脚本未被执行时的替代内容（文本）。\n\n此标签可被用于可识别 <script> 标签但无法支持其中的脚本的浏览器。","category":"html","title":"<noscript> 标签的作用"},{"category":"html","title":"DOCTYPE 的作用是什么？","ansysis":"参考答案：\n\n相关知识点：\n\nIE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。\n\n<!DOCTYPE>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。\n\nDOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。\n回答（参考1-5）：\n\n<!DOCTYPE>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来\n进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏\n览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。\n\n在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文\n档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。"},{"ansysis":"参考答案：\nSGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。\n\nHTML 是超文本标记语言，主要是用于规定怎么显示网页。\n\nXML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，\n而 HTML 的标签都是固定的而且数量有限。\n\nXHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML \n更严格，比如标签必须都用小写，标签都必须有闭合标签等。","category":"html","title":"SGML 、 HTML 、XML 和 XHTML 的区别？"},{"ansysis":"参考答案：\nHTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空\n间。\n\n常见的行内元素有 a b span img strong sub sup button input label select textarea","category":"html","title":"行内元素定义"},{"ansysis":"参考答案：\n块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。\n\n常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p ","category":"html","title":"块级元素定义"},{"category":"html","title":"行内元素与块级元素的区别？","ansysis":"参考答案：\nHTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。\n\n（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。\n（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。\n（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei\n     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。"},{"ansysis":"参考答案：\nHTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前\n端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为\ninline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为\ninline 与 block 已经不再符合实际需求。\n\nHTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive","category":"html","title":"HTML5 元素的分类"},{"title":" 空元素定义","ansysis":"参考答案：\n标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。\n\n常见的空元素有：br hr img input link meta","category":"html"},{"ansysis":"参考答案：\nlink 标签定义文档与外部资源的关系。\n\nlink 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。\n\nlink 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。","category":"html","title":"link 标签定义"},{"ansysis":"参考答案：\n\n（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加\n     载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。\n\n（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。\n\n（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容\n     性问题。\n\n（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i\n    mport 的方式插入样式。","category":"html","title":"页面导入样式时，使用 link 和 @import 有什么区别？"},{"title":"async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）","ansysis":"参考答案：\n\n （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执\n     行。\n\n （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。\n     当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。\n\n （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执\n     行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。","category":"html"},{"ansysis":"参考答案：\n\n Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加\n 载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析\n 过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。","category":"html","title":"什么是文档的预解析？（浏览器解析过程）"},{"ansysis":"参考答案：\n\n 理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可\n 能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。\n\n 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档\n 的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，\n 最后再继续文档的解析。","category":"html","title":"CSS 如何阻塞文档解析？（浏览器解析过程）"},{"ansysis":"参考答案：\n\n FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示\n       出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底\n       部。\n\n 白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML \n      尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面\n      文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。","category":"html","title":"渲染页面时常见哪些不良现象？（浏览器渲染过程）"},{"title":" 如何优化关键渲染路径？（浏览器渲染过程）","ansysis":"参考答案：\n\n 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n （1）关键资源的数量。\n （2）关键路径长度。\n （3）关键字节的数量。\n\n 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。\n\n 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，\n 并且资源越大，下载所需的往返次数就越多。\n\n 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它\n 们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n\n 优化关键渲染路径的常规步骤如下：\n\n （1）对关键路径进行分析和特性描述：资源数、字节数、长度。\n （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。\n （3）优化关键字节数以缩短下载时间（往返次数）。\n （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。","category":"html"},{"ansysis":"参考答案：\n\n 重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。\n \n 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。\n\n 常见引起回流属性和方法：\n\n 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。\n\n （1）添加或者删除可见的 DOM 元素；\n （2）元素尺寸改变——边距、填充、边框、宽度和高度\n （3）内容变化，比如用户在 input 框中输入文字\n （4）浏览器窗口尺寸改变——resize事件发生时\n （5）计算 offsetWidth 和 offsetHeight 属性\n （6）设置 style 属性的值\n （7）当你修改网页的默认字体时。\n\n 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。","category":"html","title":"什么是重绘和回流？（浏览器绘制过程）"},{"ansysis":"参考答案：\n\n （1）使用 transform 替代 top\n\n （2）不要把节点的属性值放在一个循环里当成循环里的变量\n\n （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局\n\n （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM\n\n （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。","category":"html","title":"如何减少回流？（浏览器绘制过程）"},{"ansysis":"参考答案：\n\n 一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。","category":"html","title":"为什么操作 DOM 慢？（浏览器绘制过程）"},{"title":"DOMContentLoaded 事件和 Load 事件的区别？","ansysis":"参考答案：\n\n 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和\n 子框架的加载完成。\n\n Load 事件是当所有资源加载完成后触发的。","category":"html"},{"ansysis":"参考答案：\n\n HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n\n 新增的有：\n  \n 绘画 canvas;\n 用于媒介回放的 video 和 audio 元素;\n 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n sessionStorage 的数据在浏览器关闭后自动删除;\n 语意化更好的内容元素，比如 article、footer、header、nav、section;\n 表单控件，calendar、date、time、email、url、search;\n 新的技术 webworker, websocket;\n 新的文档属性 document.visibilityState\n\n 移除的元素有：\n\n 纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n 对可用性产生负面影响的元素：frame，frameset，noframes；","category":"html","title":"HTML5 有哪些新特性、移除了那些元素？"},{"title":"如何处理 HTML5 新标签的浏览器兼容问题？","ansysis":"参考答案：\n\n （1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器\n     支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。\n\n （2） 当然也可以直接使用成熟的框架，比如 html5shiv ;\n      `<!--[if lt IE 9]>\n      <script> src=\"https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js\"</script>\n      <![endif]-->`\n\n      [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。","category":"html"},{"title":"简述一下你对 HTML 语义化的理解？","ansysis":"参考答案：\n\n相关知识点：\n\n （1） 用正确的标签做正确的事情。\n （2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n （3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;\n （4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;\n （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n回答：\n\n 我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，\n 一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进\n 行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。\n 对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的\n 话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会\n 依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，\n 从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、fo\n oter 这些语义标签，删除了 big 、font 这些没有语义的标签。","category":"html"},{"ansysis":"参考答案：根据同源策略，cookie是区分端口的，但是浏览器实现来说，“cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的。","category":"html","title":"如何在不同的端口间共享cookie？"},{"title":"前端性能优化？","ansysis":"参考答案：前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。\\n\\n 第一个方面是页面的内容方面\\n\\n （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。\\n\\n （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。\\n\\n （3）通过设置缓存策略，对常用不变的资源进行缓存。\\n\\n （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。\\n\\n （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。\\n\\n 第二个方面是服务器方面\\n\\n （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。\\n\\n （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。\\n\\n （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie\\n\\n 第三个方面是 CSS 和 JavaScript 方面\\n\\n （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。\\n\\n （2）避免使用 @import 标签。\\n\\n （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。\\n\\n （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。","category":"html"}],"keyWord":"html","hasAnser":true,"title":"HTML 面试题"}
{"_id":"a573b43362c04fbf0000b3003638bfd5","keyWord":"css","css":[{"title":"实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。","category":"css","ansysis":""},{"title":"介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？","category":"css","ansysis":""},{"title":"CSS 隐藏元素的几种方法（至少说出三种）","category":"css","ansysis":""},{"title":"CSS 清除浮动的几种方法（至少两种）","category":"css","ansysis":""},{"title":"页面导入样式时，使用 link 和@import 有什么区别？","category":"css","ansysis":""},{"title":" 伪元素和伪类的区别？","category":"css","ansysis":""},{"title":"CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有那些？","category":"css","ansysis":""},{"title":"行内元素和块级元素的具体区别是什么？行内元素的 padding 和 margin 可设置吗？","category":"css","ansysis":""},{"title":"什么是外边距重叠？重叠的结果是什么？","category":"css","ansysis":""},{"title":"rgba()和 opacity 的透明效果有什么不同？","category":"css","ansysis":""},{"title":"css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？","category":"css","ansysis":""},{"title":"px 和 em 的区别。","category":"css","ansysis":""},{"title":"如何垂直居中一个元素？","category":"css","ansysis":""},{"title":"什么是BFC？","category":"css","ansysis":""},{"title":"用纯 CSS 创建一个三角形的原理是什么？","category":"css","ansysis":""},{"title":"Sass、LESS 是什么？大家为什么要使用他们？","category":"css","ansysis":""},{"title":"display:none 与 visibility:hidden 的区别是什么？","category":"css","ansysis":""},{"title":"移动端 1px 问题的解决办法","category":"css","ansysis":""},{"title":"哪些 css 属性可以继承？","category":"css","ansysis":""},{"title":"几种常见的 CSS 布局","category":"css","ansysis":""},{"title":"li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？","category":"css","ansysis":""},{"title":"设置元素浮动后，该元素的 display 值是多少？","category":"css","ansysis":""},{"title":"怎么让 Chrome 支持小于 12px 的文字？","category":"css","ansysis":""},{"title":"display:inline-block 什么时候会显示间隙？","category":"css","ansysis":""},{"title":"png、jpg、gif 这些图片格式解释一下，分别什么时候用？，webp 呢","category":"css","ansysis":""},{"title":"style 标签写在 body 后与 body 前有什么区别？","category":"css","ansysis":""},{"title":"超链接访问过后 hover 样式就不出现的问题是什么？如何解决？","category":"css","ansysis":""},{"title":"什么是 Css Hack？ie6, 7, 8 的 hack 分别是什么？","category":"css","ansysis":""},{"title":"重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？","category":"css","ansysis":""},{"title":"css sprite 是什么, 有什么优缺点","category":"css","ansysis":""},{"title":"什么是 FOUC? 如何避免","category":"css","ansysis":""},{"title":"css3 有哪些新特性","category":"css","ansysis":""},{"title":"display 有哪些值？说明他们的作用","category":"css","ansysis":""},{"title":" display:inline-block 什么时候不会显示间隙？","category":"css","ansysis":""},{"title":" display:inline-block 什么时候不会显示间隙？","category":"css","ansysis":""},{"title":"PNG, GIF, JPG 的区别及如何选","category":"css","ansysis":""},{"title":"行内元素 float:left 后是否变为块级元素？","category":"css","ansysis":""},{"title":" 在网页中的应该使用奇数还是偶数的字体？为什么呢？","category":"css","ansysis":""},{"title":"CSS 合并方法","category":"css","ansysis":""},{"title":"列出你所知道可以改变页面布局的属性","category":"css","ansysis":""},{"title":"CSS 在性能优化方面的实践","category":"css","ansysis":""},{"title":" CSS3 动画（简单动画的实现，如旋转等）","category":"css","ansysis":""},{"title":" base64 的原理及优缺点","category":"css","ansysis":""},{"title":"stylus/sass/less 区别","category":"css","ansysis":""},{"title":"position 的值， relative 和 absolute 分别是相对于谁进行定位的？","category":"css","ansysis":""},{"title":"对偏移、卷曲、可视的理解","category":"css","ansysis":""},{"title":"精灵图和 base64 如何选择？","category":"css","ansysis":""},{"title":"如果设计中使用了非标准的字体，你该如何去实现？","category":"css","ansysis":""},{"title":"知道 css 有个 content 属性吗？有什么作用？有什么应用？","category":"css","ansysis":""},{"title":"CSS 选择器的优先级是如何计算的？","category":"css","ansysis":""},{"title":"请阐述 Float 定位的工作原理。","category":"css","ansysis":""},{"title":"请阐述 z-index 属性，并说明如何形成层叠上下文（stacking context）","category":"css","ansysis":""},{"title":"如何解决不同浏览器的样式兼容性问题？","category":"css","ansysis":""},{"title":"如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？","category":"css","ansysis":""},{"title":"对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？","category":"css","ansysis":""},{"title":"解释浏览器如何确定哪些元素与 CSS 选择器匹配。","category":"css","ansysis":""},{"title":"说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。","category":"css","ansysis":""},{"title":"* { box-sizing: border-box; } 会产生怎样的效果？","category":"css","ansysis":""},{"title":"relative 、 fixed 、 absolute 和 static 四种定位有什么区别？","category":"css","ansysis":""},{"title":"你使用过哪些现有的 CSS 框架？你是如何改进它们的？","category":"css","ansysis":""},{"title":"你了解 CSS Flex 和 Grid 吗？","category":"css","ansysis":""},{"title":"你了解 CSS Flex 和 Grid 吗？","category":"css","ansysis":""},{"title":"响应式设计与自适应设计有何不同？","category":"css","ansysis":""},{"title":"你有没有使用过视网膜分辨率的图形？当中使用什么技术？","category":"css","ansysis":""},{"title":"什么情况下，用 translate() 而不用绝对定位？什么时候，情况相反","category":"css","ansysis":""},{"title":"一边固定宽度一边宽度自适应","category":"css","ansysis":""},{"title":"display:none、visibile:hidden、opacity:0 的区别","category":"css","ansysis":""},{"title":"文本超出部分显示省略号","category":"css","ansysis":""},{"title":"利用伪元素画三角","category":"css","ansysis":""},{"title":"过渡与动画的区别是什么","category":"css","ansysis":""},{"title":"去除 inline-block 元素间间距的方法","category":"css","ansysis":""},{"title":" 为什么要初始化 CSS 样式","category":"css","ansysis":""},{"title":"设备像素比","category":"css","ansysis":""},{"title":"::bofore 和 :after 中双冒号和单冒号有什么区别？","category":"css","ansysis":""},{"title":" 有哪些手段可以优化 CSS, 提高性能","category":"css","ansysis":""},{"title":"transform translate transition 的区别","category":"css","ansysis":""},{"title":"全屏滚动的原理是什么？用到了 CSS 的那些属性？","category":"css","ansysis":""},{"title":"你对 line-height 是如何理解的？","category":"css","ansysis":""}],"title":"CSS 面试题"}
{"_id":"26da8e4962c052f9018fda6c3bb35868","keyWord":"js","js":[{"title":"document load 和 document ready 的区别","category":"js","ansysis":""},{"title":"JavaScript 中如何检测一个变量是一个 String 类型？","category":"js","ansysis":""},{"title":"请用 js 去除字符串空格？","category":"js","ansysis":""},{"title":"js 是一门怎样的语言，它有什么特点","category":"js","ansysis":""},{"title":"== 和 === 的不同","category":"js","ansysis":""},{"title":"怎样添加、移除、移动、复制、创建和查找节点？","category":"js","ansysis":""},{"title":"事件委托是什么","category":"js","ansysis":""},{"title":"require 与 import 的区别","category":"js","ansysis":""},{"title":"javascript 对象的几种创建方式","category":"js","ansysis":""},{"title":"JavaScript 继承的方式和优缺点","category":"js","ansysis":""},{"title":"什么是原型链？","category":"js","ansysis":""},{"title":"复杂数据类型如何转变为字符串","category":"js","ansysis":""},{"title":"javascript 的 typeof 返回哪些数据类型","category":"js","ansysis":""},{"title":"javascript 的 typeof 返回哪些数据类型","category":"js","ansysis":""},{"title":"一次js请求一般情况下有哪些地方会有缓存处理？","category":"js","ansysis":""},{"title":"列举 3 种强制类型转换和 2 种隐式类型转换","category":"js","ansysis":""},{"title":"你对闭包的理解？优缺点？","category":"js","ansysis":""},{"title":"如何判断 NaN","category":"js","ansysis":""},{"title":"new 一个对象的过程中发生了什么","category":"js","ansysis":""},{"title":"for in 和 for of的区别","category":"js","ansysis":""},{"title":"如何判断 JS 变量的一个类型（至少三种方式）","category":"js","ansysis":""},{"title":"for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？","category":"js","ansysis":""},{"title":"iframe 跨域通信和不跨域通信","category":"js","ansysis":""},{"title":"H5 与 Native 如何交互","category":"js","ansysis":""},{"title":"如何判断一个对象是否为数组","category":"js","ansysis":""},{"title":"<script> 标签的 defer 和 asnyc 属性的作用以及二者的区别？","category":"js","ansysis":""},{"title":"Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏","category":"js","ansysis":""},{"title":"什么是面向对象？","category":"js","ansysis":""},{"title":"JS 严格模式和正常模式","category":"js","ansysis":""},{"title":"移动端 click 事件、touch 事件、tap 事件的区别","category":"js","ansysis":""},{"title":"JS 单线程还是多线程，如何显示异步操作","category":"js","ansysis":""},{"title":"JavaScript 数组的函数 map/forEach/reduce/filter","category":"js","ansysis":""},{"title":"JS 块级作用域、变量提升","category":"js","ansysis":""},{"title":"null/undefined 的区别","category":"js","ansysis":""},{"title":"JS 哪些操作会造成内存泄露","category":"js","ansysis":""},{"title":"重排与重绘的区别，什么情况下会触发？","category":"js","ansysis":""},{"title":"发布订阅设计模式","category":"js","ansysis":""},{"title":"jsonp 优缺点？","category":"js","ansysis":""},{"title":"兼容各种浏览器版本的事件绑定","category":"js","ansysis":""},{"title":"typescript 遇到过什么坑","category":"js","ansysis":""},{"title":"this 和 apply 的应用","category":"js","ansysis":""},{"title":"split() join()的区别","category":"js","ansysis":""},{"title":"JavaScript 的数据类型","category":"js","ansysis":""},{"title":"如何判断一个对象是否属于某个类？","category":"js","ansysis":""},{"title":"call() 和 apply() 的含义和区别？","category":"js","ansysis":""},{"title":"sort 排序原理","category":"js","ansysis":""},{"title":"如何判断当前脚本运行在浏览器还是 node 环境中？","category":"js","ansysis":""},{"title":"移动端最小触控区域是多大？","category":"js","ansysis":""},{"title":"移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？","category":"js","ansysis":""},{"title":"解释 JavaScript 中的作用域与变量声明提升？","category":"js","ansysis":""},{"title":"Node.js 的适用场景？","category":"js","ansysis":""},{"title":"bind、call、apply 的区别","category":"js","ansysis":""},{"title":"使用构造函数的注意点","category":"js","ansysis":""},{"title":"如何获取浏览器版本信息","category":"js","ansysis":""},{"title":"如何实现文件断点续传","category":"js","ansysis":""},{"title":"数组的常用方法","category":"js","ansysis":""},{"title":"字符串常用操作","category":"js","ansysis":""},{"title":"字符串常用操作","category":"js","ansysis":""},{"title":"作用域的概念及作用","category":"js","ansysis":""},{"title":"作用域的分类","category":"js","ansysis":""},{"title":"js 属于哪种作用域","category":"js","ansysis":""},{"title":"浮点数精度","category":"js","ansysis":""},{"title":"自执行函数? 用于什么场景？好处?","category":"js","ansysis":""},{"title":"多个页面之间如何进行通信","category":"js","ansysis":""},{"title":"css 动画和 js 动画的差异","category":"js","ansysis":""},{"title":"如何做到修改 url 参数页面不刷新","category":"js","ansysis":""},{"title":"数组方法 pop() push() unshift() shift()","category":"js","ansysis":""},{"title":"事件绑定与普通事件有什么区别","category":"js","ansysis":""},{"title":"IE 和 DOM 事件流的区别","category":"js","ansysis":""},{"title":"如何阻止冒泡与默认行为","category":"js","ansysis":""},{"title":"js 中 this 闭包 作用域","category":"js","ansysis":""},{"title":"javascript 的本地对象，内置对象和宿主对象","category":"js","ansysis":""},{"title":"javascript 的同源策略","category":"js","ansysis":""},{"title":"事件冒泡与事件捕获","category":"js","ansysis":""},{"title":"foo = foo||bar ，这行代码是什么意思？为什么要这样写？","category":"js","ansysis":""},{"title":"复杂数据类型如何转变为字符串","category":"js","ansysis":""},{"title":"javascript 中 this 的指向问题","category":"js","ansysis":""}],"title":"JavaScript 面试题"}
{"_id":"26da8e4962c05505018fda6d0f8ae6fe","keyWord":"computer","computer":[{"title":"说下 http 和 https 的区别","category":"computer","ansysis":""},{"title":"http 的缺点","category":"computer","ansysis":""},{"title":"https 的优点","category":"computer","ansysis":""},{"title":"https 协议的缺点","category":"computer","ansysis":""},{"title":"https 协议的工作原理","category":"computer","ansysis":""},{"title":"tcp 三次握手一句话概括","category":"computer","ansysis":""},{"title":"什么是 WebSocket？","category":"computer","ansysis":""},{"title":"WebSocket 是什么样的协议，具体有什么优点？","category":"computer","ansysis":""},{"title":"请求有哪几种类型？","category":"computer","ansysis":""},{"title":"get 和 post 请求的区别","category":"computer","ansysis":""},{"title":"http 常见的状态码有哪些？","category":"computer","ansysis":""},{"title":"说下 http2.0","category":"computer","ansysis":""},{"title":"fetch 发送 post 请求的时候，总是发送2次，第一次状态码是 204，第二次才成功？","category":"computer","ansysis":""}],"title":"计算机网络面试题"}
{"_id":"7a79bfab62c13f020108444837e0fad1","headerImg":"https://mmbiz.qpic.cn/mmbiz_jpg/uvBQ6bLUlsjT6j3fPZHyiap9iabKiaBdibXiatJoPaV6AZMYEzvYQpReQcOhEibzVUWoC7hOp8vYKibudlA7nUUezmIBw/0?wx_fmt=jpeg","showData":{"serviceContent":[{"title":"前端基础","subTitle":"包含 HTML、CSS、JS 以及计算机网络的面试题","jumpUrl":"/pages/interview/interview","icon":"/images/icon/jichu-Basics.png"},{"title":"高频题目","subTitle":"面试中常见且必须要熟悉和掌握的题目","jumpUrl":"/pages/listPage/listPage","keyWord":"highFrequency","icon":"/images/icon/important.png"},{"title":"知识体系","subTitle":"学习前端需要了解及掌握的各类知识点","jumpUrl":"/pages/frame/frame","keyWord":"freamWork","icon":"/images/icon/financial_framework.png"},{"title":"文章分享","subTitle":"一些公众号文章，有关职场新人的注意事项","jumpUrl":"/pages/otherShare/otherShare","icon":"/images/icon/kuozhangongneng.png"}],"gotoMiniApp":[{"title":"C 语言","icon":"/images/icon/cyuyan.png","appId":"wx6bebdccd4af55c3d","path":"pages/finalExam/finalExam"}]},"title":"首页数据"}
{"_id":"6a6a269a62c1880b01104dac7d30d75a","keyWord":"highFrequency","hasAnser":true,"title":"前端高频面试题","highFrequency":[{"ansysis":"语义化就是选择与语义相符合的标签，使代码语义化，这样不仅便于开发者进行阅读，同时也能维护和写出更优雅的代码，还能够让搜索引擎和浏览器等工具更好地解析。\n通俗的讲语义化就是让正确的标签做正确的事情，比如段落用p标签，头部用header标签，主要内容用main标签，侧边栏用aside标签等等。","category":"highFrequency","title":"说一下对HTML语义化的理解?"},{"ansysis":"将视口大小设置为可视区域的大小。\n什么是视口\n视口简单理解就是可视区域大小。\n在PC端，视口大小就是浏览器窗口可视区域的大小\n在移动端, 视口大小并不等于窗口大小, 移动端视口宽度被人为定义为了980\n为什么移动端视口宽度是980而不是其他的值\n因为过去网页的版心都是980的，为了能够让网页在移动端完美的展示, 所以将手机视口的大小定义为了980。\n移动端自动将视口宽度设置为980带来的问题\n虽然移动端自动将视口宽度设置为980之后让我们可以很完美的看到整个网页，但是由于移动端的物理尺寸(设备宽度)是远远小于视口宽度的，所以为了能够在较小的范围内看到视口中所有的内容, 那么就必须将内容缩小。\n但是缩小后用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。\n如何保证在移动端不自动缩放网页的尺寸\n通过meta设置视口大小\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\nviewport 是指 web 页面上用户的可视区域。\nmeta标签的属性:\nwidth=device-width 设置视口宽度等于设备的宽度\ninitial-scale=1.0 初始缩放比例, 1不缩放\nmaximum-scale：允许用户缩放到的最大比例\nminimum-scale：允许用户缩放到的最小比例\nuser-scalable：用户是否可以手动缩放","category":"highFrequency","title":"meta viewport 是做什么用的"},{"ansysis":".clearfix:after { \n    /*生成内容作为最后一个元素*/ \n    content: \"\"; \n    /*使生成的元素以块级元素显示,占满剩余空间*/ \n    display: block; \n    /*避免生成内容破坏原有布局的高度*/ \n    height: 0; \n    /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/ \n    visibility: hidden; \n    /*清除浮动元素对当前元素的影响*/ \n    clear: both; \n} \n.clearfix { \n    /*用于兼容IE, 触发IE hasLayout*/ \n    *zoom:1; \n}\n","category":"highFrequency","title":"清除浮动"},{"ansysis":"Scss其实是Sass的改进版本\nScss是Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此Sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。\n\n\nLess环境较Sass简单\nSass的安装需要安装Ruby环境，Less基于JavaScript，需要引入Less.js来处理代码输出css\n\n\n变量符不一样，Less是@，而Sass是$，而且变量的作用域也不一样。\nSass没有局部变量，满足就近原则。Less中{}内定义的变量为局部变量。\n\n\nLess没有输出设置，Sass提供4中输出选项\n输出样式的风格可以有四种选择，默认为nested\nnested：嵌套缩进的css代码\nexpanded：展开的多行css代码\ncompact：简洁格式的css代码\ncompressed：压缩后的css代码\n\n\nSass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。\n\n\nLess与Sass处理机制不一样\nLess是通过客户端处理的，Sass是通过服务端处理，相比较之下Less解析会比Sass慢一点\n\n\nSass和Less的工具库不同\nSass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在     它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。\nLess有UI组件库Bootstrap, Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写，不过Bootstrap4也开始用Sass编写了。","category":"highFrequency","title":" Less/Sass/Scss的区别"},{"ansysis":"BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响，它属于定位方案的普通流。\n触发条件：\n\n根元素\n浮动元素：float 除 none 以外的值（left、right）\n绝对定位元素：position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n约束规则：\n\n属于同一个 BFC 的两个相邻 Box 垂直排列\n属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\nBFC 的区域不会与 float 的元素区域重叠\n计算 BFC 的高度时，浮动子元素也参与计算\n文字层不会被浮动层覆盖，会环绕于周围\n\n作用：\n\n阻止元素被浮动元素覆盖\n一个正常文档流的块级元素可能被一个浮动元素覆盖，挤占正常文档流，因此可以设置一个元素的float、display、position或者overflow值等方式触发BFC，以阻止被浮动盒子覆盖。\n可以包含浮动元素（清除浮动）\n通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。\n阻止相邻元素的margin合并\n属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。\n","category":"highFrequency","title":"BFC及其应用"},{"ansysis":"子绝父相 + transform\n\n.parent {\n    position: relative;\n}\n\n.son {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n}\n\n\n伸缩布局\n\n.parent {\n    display:flex;\n    justify-content:center;\n    align-items: center;\n}\n","category":"highFrequency","title":"水平垂直居中"},{"ansysis":"闭包的实质是因为函数嵌套而形成的作用域链\n比如说：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包\n用途：使用闭包主要是为了设计私有的方法和变量\n优点：可以避免变量被全局变量污染\n缺点：函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包\n解决方法：在退出函数之前，将不使用的局部变量全部删除\n\n还需要了解闭包的使用场景\n","category":"highFrequency","title":"什么是闭包?"},{"ansysis":"选择排序\n\nlet arr = [3, 4, 1, 2];\nlet len = arr.length;\n//  这里之所以是len-1，是因为到最后两个元素，交换位置，整个数组就已经排好序了。\nfor(let i = 0; i < len - 1; i++){\n    let min = arr[i];\n    // j = i+1是把与自己比较的情况给省略掉\n    for(let j = i+1; j < len; j++){\n        if(arr[j] < min){\n            // 利用ES6数组的解构赋值交换数据\n            [arr[j], min] = [min, arr[j]];\n        }\n    }\n    arr[i] = min;\n}\nconsole.log(arr);\n\n\n冒泡排序\n\nlet arr = [3, 4, 1, 2];\nlet max = arr.length - 1;\nfor(let i = 0; i < max; i++){\n    // 声明一个变量，作为标志位\n    // 如果某次循环完后，没有任何两数进行交换，就将标志位设置为 true，表示排序完成\n    let flag = true;\n    for(let j = 0; j < max - i; j++){\n        if(arr[j] > arr[j + 1]){\n            // 利用ES6数组的解构赋值交换数据\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            flag = false;\n        }\n    }\n    if(flag){\n        break;\n    }\n}\nconsole.log(arr);\n","category":"highFrequency","title":"手写选择排序和冒泡排序"},{"ansysis":"数组去重\n方法 1\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员\n// 去除数组的重复成员\n[...new Set([1, 2, 2, 3, 4, 5, 5])];\n// [1, 2, 3, 4, 5]\n\n方法 2\nArray.from()能把set结构转换为数组\nArray.from(new Set([1, 2, 2, 3, 4, 5, 5]));\n// [1, 2, 3, 4, 5]\n\n方法 3（ES5）\nfunction unique(arr) {\n  let temp = [];\n  arr.forEach(e => {\n    if (temp.indexOf(e) == -1) {\n      temp.push(e);\n    }\n  });\n\n  return temp;\n}\n\n反转数组\n要求\n输入: I am a student  输出: student a am I\n输入是数组 输出也是数组 不允许用 split splice reverse\n解法一\nfunction reverseArray(arr) {\n    let str = arr.join(' ')\n    let result = []\n    let word = ''\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] != ' ') {\n            word += str[i]\n        } else {\n            result.unshift(word)\n            word = ''\n        }\n    }\n    \n    result.unshift(word)\n    return result\n}\n\nconsole.log(reverseArray(['I', 'am', 'a', 'student']))\n// [\"student\", \"a\", \"am\", \"I\"]\n\n解法二\nfunction reverseArray(arr) {\n    let result = []\n    let distance = arr.length - 1\n    for (let i = 0; i <= distance; i++) {\n        result[i] = arr[distance - i]\n    }\n\n    return result\n}","category":"highFrequency","title":"数组去重和反转数组"},{"ansysis":"函数节流\n函数节流是优化高频率执行js代码的一种手段\n可以减少高频调用函数的执行次数\n函数防抖\n函数防抖是也优化高频率执行js代码的一种手段\n可以让被调用的函数在一次连续的高频操作中只被调用一次\n\n作用：减少代码执行次数, 提升网页性能\n应用场景：oninput / onmousemove / onscroll / onresize 等事件\n函数节流和函数防抖区别\n函数节流是减少连续的高频操作函数执行次数 (例如连续调用10次, 可能只执行3-4次)\n函数防抖是让连续的高频操作时函数只执行一次(例如连续调用10次, 但是只会执行1次)\n\n函数实现","category":"highFrequency","title":"函数节流和函数防抖"},{"ansysis":"每个\"构造函数\"中都有一个默认的属性, 叫做 prototype, prototype属性保存着一个对象, 这个对象我们称之为\"原型对象\", prototype 指向它的原型对象\n每个\"原型对象\"中都有一个默认的属性, 叫做constructor, constructor 指向当前原型对象对应的那个\"构造函数\"\n通过构造函数创建出来的对象我们称之为\"实例对象\", 每个\"实例对象\"中都有一个默认的属性, 叫做__proto__, __proto__ 指向创建它的那个构造函数的\"原型对象\"\n基本关系\n  1. 所有函数都是Function构造函数的实例对象\n  2. 所有函数都是对象, 包括Function构造函数\n  3. 所有对象都有__proto__属性\n  4. 普通对象的__proto__属性指向创建它的那个构造函数对应的\"原型对象\"\n\n特殊关系\n   5. 所有对象的__proto__属性最终都会指向\"Object原型对象\"\n   6. \"Object原型对象\"的__proto__属性指向NULL\n\n对象中__proto__组成的链条我们称之为原型链\n对象在查找属性和方法的时候, 会先在当前对象查找, 如果有就用自己的\n如果当前对象中找不到想要的, 会依次去上一级原型对象中查找\n如果找到Object原型对象都没有找到, 就会报错\n","category":"highFrequency","title":"原型和原型链"},{"ansysis":"ew一个对象的四个过程：\n1、创建一个空对象\nlet obj = {};\n\n2、让构造函数中的this指向新对象，并执行构造函数的函数体\nlet result = Person.call(obj);\n\n3、设置新对象的__proto__属性指向构造函数的原型对象\nobj.__proto__ = Person.prototype;\n\n4、判断构造函数的返回值类型，如果是值类型，则返回新对象。如果是引用类型，就返回这个引用类型的对象。\n\nif (typeof(result) == \"object\") \n    p = result;\nelse \n    p = obj;\n","category":"highFrequency","title":"new一个对象的时候发生了什么?"},{"ansysis":"ES5继承\n\n在子类中通过call / apply方法借助父类的构造函数\n将子类的原型函数设置为父类的实例对象\nES6继承\n\n通过子类extends父类, 来告诉浏览器子类要继承父类\n通过super()方法修改 this","category":"highFrequency","title":"ES5继承和ES6继承"},{"ansysis":"深拷贝\n修改新变量的值不会影响原有变量的值\n默认情况下基本数据类型都是深拷贝\n\n浅拷贝\n修改新变量的值会影响原有变量的值\n默认情况下引用类型都是浅拷贝\n\n通过自定义函数实现深拷贝，具体代码请自行查找～","category":"highFrequency","title":"深拷贝和浅拷贝，以及如何实现对象深拷贝"},{"title":"进程和线程的区别","ansysis":"进程是程序的一次执行过程，是一个动态概念，是操作系统资源分配的基本单位\n线程是任务调度和执行的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源\n\n一个程序至少有一个进程,一个进程至少有一个线程\n线程的划分尺度小于进程，使得多线程程序的并发性高\n另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率\n线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制\n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别","category":"highFrequency"},{"ansysis":"JS是单线程的\n所以JS中的代码都是串行的, 前面没有执行完毕后面不能执行\nJavaScript的单线程，与它的用途有关。\n作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。\n这决定了它只能是单线程，否则会带来很复杂的同步问题。\n例如: 如果JS是多线程的\n现在有一个线程要修改元素中的内容, 一个线程要删除该元素, 这时浏览器不知道以哪个线程为准\n除了\"事件绑定的函数\"和\"回调函数\"以外的都是同步代码\n程序运行会从上至下依次执行所有的同步代码\n在执行的过程中如果遇到异步代码会将异步代码放到事件循环中\n当所有同步代码都执行完毕后, JS会不断检测 事件循环中的异步代码是否满足条件\n一旦满足条件就执行满足条件的异步代码\n开发中为了保存异步代码的执行顺序, 那么就会出现回调函数层层嵌套\n如果回调函数嵌套的层数太多, 就会导致代码的阅读性, 可维护性大大降低\npromise是ES6中新增的异步编程解决方案, 在代码中的表现是一个对象\npromise对象可以将异步操作以同步流程来表示, 避免了回调函数层层嵌套问题，避免了回调地狱问题\n","category":"highFrequency","title":"说一下JS异步编程"},{"ansysis":"promise是ES6中新增的异步编程解决方案, 在代码中的表现是一个对象\n开发中为了保存异步代码的执行顺序, 那么就会出现回调函数层层嵌套\n如果回调函数嵌套的层数太多, 就会导致代码的阅读性, 可维护性大大降低\npromise对象可以将异步操作以同步流程来表示, 避免了回调函数层层嵌套问题，避免了回调地狱问题\n我们可以通过 new Promise(function(resolve, reject){}); 来创建一个promise对象，但创建的promise对象不是异步的, 只要创建promise对象就会立即执行存放的代码\npromise对象是通过状态的改变来实现通过同步的流程来表示异步的操作的, 只要状态发生改变就会自动触发对应的函数\nPromise对象有三种状态，分别是\npending:   默认状态，只要没有告诉promise任务是成功还是失败就是pending状态  \nfulfilled(resolved): 只要调用resolve函数, 状态就会变为fulfilled, 表示操作成功  \nrejected:  只要调用rejected函数, 状态就会变为rejected, 表示操作失败  \n\n状态一旦改变既不可逆, 从pending变为fulfilled, 那么永远都是fulfilled，从pending变为rejected, 那么永远都是rejected\n可以通过函数来监听Promise状态的变化\n成功执行  then() 函数的回调\n失败执行  catch() 函数的回调\nPromise的then方法\nthen方法接收两个参数,\n第一个参数是状态切换为成功时的回调,\n第二个参数是状态切换为失败时的回调\nPromise的catch方法\ncatch 其实是 then(undefined, () => {}) 的语法糖\nPromise的all静态方法:\n1.all方法接收一个数组,\n2.如果数组中有多个Promise对象,只有都成功才会执行then方法,  并且会按照添加的顺序, 将所有成功的结果重新打包到一个数组中返回给我们\n3.如果数组中不是Promise对象, 那么会直接执行then方法\n应用场景: 批量加载, 要么一起成功, 要么一起失败\nPromise的race静态方法:\n1.race方法接收一个数组,\n2.如果数组中有多个Promise对象, 谁先返回状态就听谁的, 后返回的会被抛弃\n3.如果数组中不是Promise对象, 那么会直接执行race方法\n应用场景: 接口调试, 超时处理\n","category":"highFrequency","title":"什么是promise"},{"ansysis":"跨域是相对于同源策略而言的。\n同源策略是一种约定，它是浏览器最核心也最基本的安全功能\n所谓同源是指: 协议，域名，端口都相同,就是同源, 否则就是跨域\n同源策略带来的影响\n在同源策略下, 浏览器只允许Ajax请求同源的数据, 不允许请求不同源的数据\n但在企业开发中, 一般情况下为了提升网页的性能, 网页和数据都是单独存储在不同服务器上的\n这时如果再通过Ajax请求数据就会拿不到跨域数据\n跨域解决方案\n可以使用 jsonp\nJSONP让网页从跨域的地址那获取资料，即跨域读取数据","category":"highFrequency","title":"什么是跨域，以及如何解决跨域问题？"},{"ansysis":"HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头\nHTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密\nHTTP 的端口号是 80，HTTPS 是 443\nHTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费\nHTTP 的连接很简单，是无状态的；\nHTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n","category":"highFrequency","title":"HTTP和HTTPS的区别"},{"ansysis":"100-199 用于指定客户端应响应的某些动作\n200-299 用于表示请求成功\n300-399 用于已重定向的文件\n400-499 用于指出客户端的错误\n400：语义有误，当前请求无法被服务器理解\n401：当前请求需要用户验证\n403：服务器已经理解请求，但是拒绝执行它\n404：请求的内容不存在。\n500-599 用于指出服务器错误\n503：服务不可用","category":"highFrequency","title":"HTTP的状态码说一下"},{"ansysis":"提交数据存储位置不同\n\nGET请求会将数据放到URL后面\nPOST请求会将数据放到请求体中\n\n对提交的数据大小限制不同\n\nGET请求对所发信息量的限制是2000 个字符\nPOST请求对信息量没有限制\n\n对提交的数据编码不同\n\nGET请求的参数只能是ASCII码，所以中文需要URL编码\nPOST请求传参没有这个限制\n\n应用场景不同\n\nGET请求用于提交非敏感数据和小数据\nPOST请求用于提交敏感数据和大数据\n\nget请求可以被缓存，post不可以被缓存\nget后退不会有影响，post后退会重新进行提交\nget请求的记录会留在历史记录中，post请求不会留在历史记录\n","category":"highFrequency","title":"get和post的区别"},{"title":"Cookie、SessionStronge、LocalStronge的区别","ansysis":"在同一浏览器下生命周期不同\n\nCookie生命周期:         默认是关闭浏览器后失效, 但是也可以设置过期时间\nSessionStorage生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间\nLocalStorage生命周期:   除非被清除，否则永久保存\n\n容量不同\n\nCookie容量限制:         大小(4KB左右)和个数(20~50)\nSessionStorage和LocalStorage容量限制: 大小(5M左右)\n\n网络请求不同\n\nCookie网络请求:         每次都会携带在HTTP请求头中，如果使用cookie保存过多数据会带来性能问题\nSessionStorage和LocalStorage网络请求: 仅在浏览器中保存，不参与和服务器的通信\n\n应用场景不同\n\nCookie:         判断用户是否登录\nsessionStorage: 表单数据\nLocalStorage:   购物车\n\n需要注意的是：无论通过哪种方式存储的数据, 都不能将敏感数据直接存储到本地\n","category":"highFrequency"},{"ansysis":"ajax简单来说是通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。\najax的优点\n\n最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。\n使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。\n可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求。\n基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。\n\najax的缺点\n\najax对浏览器后退机制造成了破坏，也就是说用户无法通过浏览器的后退按钮回到前一次操作的页面。虽然有些浏览器解决了这个问题，但它也并不能改变ajax的机制，它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。\n安全问题。技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。\n对搜索引擎的支持比较弱。\n破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。\n另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。\n一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的。\n\najax的四个步骤\n\n创建一个异步对象\n\nlet xmlhttp = new XMLHttpRequest();\n\n\n设置请求方式和请求地址\n\nopen(method,url,async)  规定请求的类型、URL 以及是否异步处理请求。\nmethod：请求的类型；GET 或 POST\nurl：文件在服务器上的位置\nasync：true（异步）或 false（同步）\nxmlhttp.open(\"GET\",\"04-ajax-get.php\",true);\n\n\n发送请求\n\nxmlhttp.send();\n\n\n监听状态的变化\n","category":"highFrequency","title":"Ajax的优缺点和四个步骤"},{"category":"highFrequency","title":"前端对后端返回的数据如何处理","ansysis":"前端通过javascript对后端返回的json或者xml进行格式化处理\nJSON:\nvar jsonObj = JSON.parse(后端返回的json字符串);\nvar result = JSON.stringify(jsonObj, null, 2);//格式化\n\nXML：\n先使用 xml2json转化为JSON格式，然后再JSON.parse再JSON.stringfy进行格式化\n"},{"ansysis":"这是一个前端面试非常经典的面试题，这个题目很深，涉及的知识点很广，我这里只是简单概括，如果想进一步了解，可自行搜索\n1. 浏览器会进行DNS域名解析，拿到域名对应的服务器ip地址，再用该ip去访问web服务器\n2. 然后会和web服务器进行tcp的三次握手建立tcp连接\n3. 连接建立成功后，浏览器会发送http的get请求\n4. 服务器收到请求并给予响应，返回请求的数据\n5. 浏览器拿到数据并进行解析、渲染\n6. 浏览器和服务器进行tcp的四次挥手，断开连接\n","category":"highFrequency","title":" 从输入 URL 到页面加载完成的过程中都发生了什么(重点)"},{"ansysis":"三次握手\n\n\n第一次握手(SYN=1, seq=x):\n\n\n客户端发送一个 TCP的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口(请求同步)，并选择序号 seq=x，表明传送数据时的第一个数据字节的序号是 x。(seq是个随机值)\n发送完毕后，客户端进入 SYN_SEND 状态。\n\n\n\n\n第二次握手(SYN=1, ACK=1, seq=y, ack=x+1):\n\n\n服务器的TCP收到连接请求报文段后，如同意，则发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号(随机值y)，放到seq 域里，同时将确认序号ack设置为客户的 ISN 加1，即 x+1(即回复对方确认收到了序列号为x开始的包，且希望下次的数据从x+1的位置开始)。\n发送完毕后，服务器端进入 SYN_RCVD 状态。\n\n\n\n\n第三次握手(ACK=1，ack=y+1，seq=x+1)\n\n\n客户端收到此报文段后再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段ack中发送给对方，并且告诉服务器自己的seq=x+1\n发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP握手结束。\n\n\n\n\n四次挥手\n1.第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。\n2.第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态。\n3.第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态。\n4.第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1， 服务端进入CLOSED状态，完成四次挥手\n","category":"highFrequency","title":"详细说一下 TCP 的三次握手和四次挥手过程(重点)"},{"ansysis":"1.解析HTML生成DOM树  \n2.解析CSS生成CSSOM规则树  \n3.将DOM树和CSSOM规则树合并在一起生成渲染树  \n4.遍历渲染树开始布局，计算每个节点的位置大小信息  \n5.将渲染树的每个节点绘制到屏幕","category":"highFrequency","title":"说一下浏览器渲染机制"},{"ansysis":"1.JS是单线程的\n  JS中的代码都是串行的, 前面没有执行完毕后面不能执行\n\n2.执行顺序\n2.1程序运行会从上至下依次执行所有的同步代码\n2.2在执行的过程中如果遇到异步代码会将异步代码放到事件循环中\n2.3当所有同步代码都执行完毕后, JS会不断检测 事件循环中的异步代码是否满足条件\n2.4一旦满足条件就执行满足条件的异步代码\n\n3.宏任务和微任务\n在JS的异步代码中又区分\"宏任务(MacroTask)\"和\"微任务(MicroTask)\"\n宏任务: 宏/大的意思, 可以理解为比较费时比较慢的任务\n微任务: 微/小的意思, 可以理解为相对没那么费时没那么慢的任务\n\n4.常见的宏任务和微任务\nMacroTask: setTimeout, setInterval, setImmediate（IE独有）...\nMicroTask: Promise, MutationObserver ,process.nextTick（node独有) ...\n注意点: 所有的宏任务和微任务都会放到自己的执行队列中, 也就是有一个宏任务队列和一个微任务队列\n        所有放到队列中的任务都采用\"先进先出原则\", 也就是多个任务同时满足条件, 那么会先执行先放进去的\n\n5.完整执行顺序\n1.从上至下执行所有同步代码\n2.在执行过程中遇到宏任务就放到宏任务队列中,遇到微任务就放到微任务队列中\n3.当所有同步代码执行完毕之后, 就执行微任务队列中满足需求所有回调\n4.当微任务队列所有满足需求回调执行完毕之后, 就执行宏任务队列中满足需求所有回调\n... ...\n注意点:\n每执行完一个宏任务都会立刻检查微任务队列有没有被清空, 如果没有就立刻清空\n","category":"highFrequency","title":"说一下浏览器事件环"}]}
